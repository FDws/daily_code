# 自动化测试

## 软件测试
1. 定义 
    - 第一类测试: 在既定的状况条件下, 运行一个系统或者组件, 观察记录结果, 并对其某些方面进行评估的过程
    - 第二类测试: 软件测试是为了发现错误而运行程序的过程
2. 软件缺陷: 软件缺陷就是软件产品中所存在的问题, 表现为用户所需要的功能没有完全实现, 不能满足或者不能完全满足用户的需求.
3. 不同分类方法:
    - 最普遍的测试策略:
        - 黑盒测试(功能性测试或者数据驱动测试): 在测试时, 把被测程序看作一个黑盒, 在完全不考虑程序内部结构和内部特性的情况下进行
        - 白盒测试(结构测试/逻辑驱动测试/基于程序的测试): 测试时可以看到被测试的源程序, 可用于分析程序内部结构, 并且根据内部结构设计测试用例
        - 灰盒测试: 介于黑盒测试和白盒测试之间, 此种测试方法关注输出对于输入的正确性, 同时也关注内部表现
    - 新技术:
        - 基于模型的测试
        - 面向对象测试
        - Web测试
        - 敏捷测试
        - 模糊测试
## 功能性测试(黑盒)
1. 等价类划分: 将所有可能的输入数据划分为若干个等价类, 然后在每一个等价类中选择少数具有代表性的数据作为测试数据
    - 划分
        - 有效等价类: 符合规格说明要求的合理输入集合, 主要用来检验程序是否已经实现了规格说明预先规定的功能和性能
        - 无效等价类: 不符合规格说明要求的不合理输入或者非法的输入集合, 主要用来检验程序是否已经做了不符合规格说明要求的事情
    - 设计测试用例
        - 确定等价类, 列出所划分出的等价类表     
            | 输入条件|有效等价类|无效等价类|    
            |:--:|:--:|:--:|
            |  |  |
            |  |  |      
        - 利用等价类设计测试用例
    - 存在问题
        - 规格说明往往没有定义无效输入时的输出
        - 强类型语言不必考虑无效输入
2. 边界值分析
    - 边界条件: 软件计划的操作界限所在的边缘条件
    - 边界值分析设计测试用例: 通过使所有变量取正确值, 只使一个变量分别取最小值/最大值/略低于最大值/略高于最小值. 对于一个n变量的程序, 边界值分析会产生4n+1个测试用例
    - 健壮性边界测试
        - 在边界值分析测试用例的基础上, 添加 略高于最大值/略低于最小值 的两个测试用例, 共产生 6n+1个测试用例
        - 有意义的使预期的输出, 观察例外情况如何处理
    - 内部边界值
        - 数值的边界值检验        
            |项|范围|
            |:--:|:--:|
            |位(bit)|1或者0|
            |字节(byte)|0~255|
            |字(word)|0~65535/ 0~4294967295|
            |千(K)|1024|
            |兆(M)|1048576|
            |吉(G)|1073741824|    
        - 字符的边界值(ASCII/Unicode)
3. 正交分析法
    - 利用正交表安排实验方案以及实验结果
    - 步骤
        - 提取功能说明, 构造因子-状态表
        - 加权筛选, 生成因素分析表
        - 利用正交表构造测试数据集
## 结构性测试(白盒测试)
1. 基于覆盖的测试
2. 语句覆盖: 设计若干个测试用例, 运行被测程序, 使得每一条可执行语句至少执行一次. 最弱的逻辑覆盖准则
3. 分支覆盖: 设计若干个测试用例, 运行被测程序, 使得每个判断的真分支和假分支至少执行一次. 
4. 条件覆盖: 设计若干个测试用例, 运行被测程序, 使得程序中每个判断的每个条件的可能取值至少执行一次
5. 分支条件覆盖: 设计足够的测试用例, 使得判断中每个条件的所有可能取值至少执行一次, 同时每个判断的所有可能判断结果至少执行一次, 即要求各个判断的所有可能的条件组合至少执行一次
6. 条件组合覆盖: 设计足够的测试用例, 运行被测程序, 使得每一个判断的所有可能的条件取值组合至少执行一次
7. 路径覆盖: 选取足够的测试用例, 覆盖被测试程序中的所有可能路径
8. 基本路径测试: 在程序控制流图的基础上, 通过分析控制构造的环形复杂性, 导出基本可执行路径集合, 从而设计测试用例的方法
    - 程序流图
    - 程序圈复杂度
    - 独立路径和独立路径基本集合
    - 准备测试用例
## 静态分析
1. 控制流分析
2. 数据流分析
3. 接口分析
4. 表达式分析
    - 除零异常
    - 开方负数
    - 浮点数的直接比较
    - 算数溢出
    - 数组越界
    - 数组引用错误
5. 代码检查
## 动态分析
1. 内存错误和内存泄漏
2. 常见的运行错误
    - 空指针带来的错误
    - 编译器截断处理带来的问题
    - 难以发现的数据溢出
    - 使用已经消亡的对象
    - 计算机体系不同潜藏的错误
    - 判断语句中执行顺序带来的隐患
    - 具有副作用语句带来的问题(自增/赋值)
    - ...
## 软件测试准则
1. 需求阶段
    - 需求检查: 编写测试用例之前, 需要对每个需求建立质量测度标准, 确保正确和没有需求遗漏, 将模糊的需求明确化
    - 设计测试过程, 响应需求变化
        - 单项测试需求内容, 用容易理解的自然语言, 明确的描述需要测试的内容
        - 多项测试内容, 应尽可能的剥离开来, 保证一条测试需求只包含一项测试内容
2. 测试计划的编制和测试文档
    - 测试内容
    - 测试实施方案
    - 测试步骤
    - 测试环境
    - 测试进度计划
    - 测试风险分析和应急对策
    - 测试策略
    - 测试交付清单
3. 测试设计
    - 测试用例设计(核心)
    - 测试场景设置
4. 测试执行和问题跟踪
    - 测试环境搭建
    - Bug记录与跟踪
5. 测试报告
    - 测试开发完成时编写, 对项目实施情况/项目质量/项目中遇到的问题以及解决措施进行总结分析, 从中吸取经验教训
6. 测试流程和过程的区别
    - 软件测试过程一般指的是具体的测试执行过程, 包括单元测试/集成测试/确认测试/系统测试/验收测试
    - 流程强调的是做事情的逻辑, 活动的线路
    - 软件测试不管采取什么流程进行, 都存在过程和结果
    - 过程和流程是对同一事物不同级别的描述, 并不是包含关系. 过程抓大放小, 流程事无巨细. 高层管理者重视全程的全面把握和对关键点的监督. 中层管理者以及一线的工作人员, 要严格遵守流程规范, 按流程规定的时间/入口准则/使用的技术方法/出口准则等, 完成软件开发的各项工作
## 自动化软件测试
1. 手工测试的局限性
    - 无法覆盖所有的代码路径
    - 功能性测试具有 机械性/重复性/工作量大 的特点
    - 许多错误通过手工测试很难捕捉到(多线程/死锁/资源冲突)
    - 需要模拟大量数据或者大量并发用户等各种场景时, 很难通过手工测试进行
    - 验证系统稳定性时, 手工测试无法模拟
    - 测试用例巨大, 手工测试无法短时间完成
2. 测试自动化
    - 自动化测试相对于手工测试而存在
    - 模拟手工测试步骤, 通过执行由程序语言编制的测试脚本, 自动地完成一切测试任务的工作
    - "一切" 不仅仅指的是测试执行的工作, 还包括测试的其他工作, 如缺陷管理/测试管理/环境安装/设置/维护
3. 自动化测试优势
    - 缩短周期
    - 速度/效率/准确可靠/不知疲倦
    - 节省人力成本, 降低测试成本
    - 做手工不能做
4. 自动化测试不足
    - 不能完全代替手工测试和手工测试工程师
    - 不能保障100%覆盖率
    - 不能弥补测试实践的不足
5. 自动化测试的原理和方法
    - 代码分析
        - 检查编码规范
        - 根据某种质量模型评价代码质量与复杂度
        - 一种白盒测试的自动化方法
    - 捕捉和回放
        - 一种黑盒测试的自动化方法
        - 记录用户的每一步操作, 将记录转换为脚本语言描述的过程, 模拟用户操作
        - 回放是将脚本记录的操作转换为屏幕上的操作, 记录系统的输出记录
        - 记录方式有两种: 程序用户界面的像素坐标或程序显示对象的位置, 以及相对应的操作/状态变化/属性变化
    - 脚本技术: 脚本是测试工具执行的指令集合, 也是计算机程序的一种形式
        - 线性脚本: 录制手工操作而得到的脚本
        - 结构化脚本: 类似于结构化程序设计, 具有各种逻辑结构/函数调用功能
        - 数据驱动脚本: 将测试脚本和数据分离, 测试输入数据存储在独立的文本中
        - 关键字驱动脚本: 数据驱动脚本的逻辑扩张, 封装了各种基本的操作, 每个操作由相应的函数实现
    - 自动比较
        - 运行测试脚本时, 对执行过程中的输出数值与期望数值自动比较
        - 两类比较模式
            - 验证(Verify): 失败时测试继续运行
            - 断言(Assert): 失败时退出当前测试
6. 测试工具的作用和优势
    - 作用
        - 测试自动化需要借助测试工具
        - 测试工具可以进行部分的侧式设计/实现/执行/比较工作
        - 常用的工作方式为 人工设计测试用例, 使用工具进行用例的执行和比较
    - 优势
        - 记录业务流程并生成脚本程序的能力
        - 对各种网络设备的模仿能力
        - 用有限的的资源生成高质量虚拟用户的能力
        - 对于真个软件和硬件系统中各个部分的监控能力
        - 对于测试结果的表现和分析能力

## 静态测试
1. 定义: 基于期望属性/专业经验/通用标准来对工作件的特性进行详细检查的一种测试方法
    - 工作件: 指的是静态测试的对象, 是不同种类产品的交付件, 即一切项目过程文档
2. 特性:
    - 查错和分析功能是其他测试方法不能替代的
    - 目的是今早发现和处理工作件中的缺陷
    - 寻找三类缺陷: 错误 遗漏 额外
3. 方法
    - 代码审查
        - 在编译和动态测试之前
        - 识别和消除安全缺陷
        - 有赖于程序员的经验和韧性
        - 需要自动化工具补充
        - 效率高(30%-70%的逻辑设计和编码缺陷)
    - 文档审查
        - 需求文档中的字段缺失, 描述错误, 错别字等
        - 设计错误, 不完善, 遗漏问题
        - 需求问题
4. 编码规范
    - ISO C(C11)
    - MISRC
    - C具体规范
        - 数据类型相关
            - 类型转换
            - 指针的安全规范
            - 指针的有效性
            - 结构体和联合体
        - 防范表达式失控
        - 准确的程序流程控制
            - 布尔表达式不应出现赋值操作
            - 显式的判断一个值是否为0
            - 浮点表达式不能直接比较
            - switch表达式应该以break结束
        - 构建安全的编译环境
            - 函数的定义和声明: 头文件中不允许包含可执行代码
            - 预处理: 文件中的`#include`语句之前只能是其他预处理指令或注释; C的宏定义中, 任何一个参数都应该加小括号
5. PC-Lint
    - 静态代码分析工具, 命令行工具, 能够检测出许多语法逻辑上的隐患, 而且也能有效的提出许多程序在空间利用/运行效率上的改进点
    - 功能
        - 检测单个文件
        - 从整个项目角度检测问题
        - 支持很多流行的编辑环境
        - 支持<<Effective C++>>中描述的各种提高效率和防止错误的方法
    - 基本使用
        - `lint-nt.ext -u -id:\lint std.lnt sample.c`
            - `-u`表示只对本单元检查
            - `-i`指定搜索文件目录
            - `std.lnt`表示要使用的配置文件
            - `sample.c`表示待检查的源文件, 支持通配符`*`
        - 常用选项      
            |选项|功能|
            |:--:|:--:|
            |-i|设置`include`路径|
            |-e#|屏蔽告警, `-e200`:屏蔽200号警告|
            |-esym(#, 符号名)|屏蔽符号名对应的告警, `-esym(39, std)`,屏蔽39号的std告警|
            |-emacro(#, 宏名称)|屏蔽宏警告|       
        - 警告分类
            - 编号<1000的为C语言, 大于的为C++
            - 信息表
                |错误说明|C|C++|警告级别|
                |:--:|:--:|:--|:--:|
                |语法错误|1-199|1001-1199|1|
                |内部错误|200-299||0|
                |致命错误|300-399||0|
                |警告|400-699|1400-1699|2|
                |消息|700-899|1700-1899|3|
                |可选信息|900-999|1900-1999|4|
            - C++的错误说明与C语言相同, 内部错误和知名错误共享
        - 警告级别       
            |级别|信息|
            |:--:|:--:| 
            |-w0|不产生信息, 除非致命错误|
            |-w1|只生成错误信息, 屏蔽警告和其他提示信息|
            |-w2|只有警告和错误|
            |-w3|默认配置, 生成警告/错误/提示信息|
            |-w4|生成所有信息|     
        - 库函数头文件信息级别       
            |级别|信息|  
            |:--:|:--:|
            |-wlib(0)|不生成任何库信息|
            |-wlib(1)|生成错误信息|
            |-wlib(2)|生成错误和警告信息|
            |-wlib(3)|生成错误/警告/提示消息(默认配置)|
            |-wlib(4)|生成所有信息|      
        - 检查种类
            - 强类型检查
                - `-strong`&`-index`可以对typeof定义的数据类型进行强类型检查
                - `strong(flags[,name]...)`
                - 选项必须在`typeof`定义之前打开
                - `flag`参数
                    - A : 对强类型变量赋值时进行类型检查
                        - i: 忽略初始化
                        - r: 忽略return
                        - p: 忽略参数传递
                        - a: 忽略赋值操作
                        - c: 忽略常量赋值
                        - z: 忽略zero赋值
                    - X : 当把强类型变量赋值给其他变量时进行类型检查
                    - J: 强类型与其他类型进行运算时检查
                        - e: 忽略 `==` `!=` `?:`
                        - r: 忽略 `>=` `>` `<` `<=`
                        - o: 忽略 `+.-.*./.%.|.^.&`
                        - c: 忽略强类型与常量运算时检查
                        - z: 忽略强类型与0运算时检查
                    - B: bool类型
                    - Tips:
                        - A和J选项的弱化字符必须紧跟之后
                        - B和b不能同时使用
                        - f必须与B或者b一起使用
                        - `-strong`的作用仅仅时声明type为强类型而不做任何检查
            - 变量值跟踪
                - 对变量值的初始化进行跟踪
                - 对应编号
                    - 644,645 变量可能没有初始化
                    - 771,772 变量不可靠的初始化
                    - 530 变量未初始化
                    - 1401-1403 成员未初始化
                - 默认函数的参数在正确范围内
            - 语义信息
            - 赋值顺序检查
                - 当一个表达式的值依赖于赋值顺序时, 告警(564) ``` a[i]=i++;func(i++,n+i);```
            - 格式检查
            - 缩进检查
            - const变量检查
            - volatile变量检查
            - 弱定义检查
        - 选项
            - 选项间空格分隔, 小写, 紧跟`/*`或者`//`
            - 选项可以放在宏定义之中, 在宏中的注释字数必须小于80
                - `#define DIVZERO(x) /*lint -save -e54 */((x)/0) /*lint -restore */`
## 单元测试
1. 单元测试是针对程序模块, 进行正确性检验的测试. 其目的在于发现各模块内部可能存在的各种差错,
2. 主要内容
    - 模块内部逻辑结构测试
    - 局部数据结构测试
    - 测试策略: 白盒测试
    - 错误处理测试: 检查模块的错误处理功能是否含有错误或缺陷
        - 是否拒绝不合理的输入
        - 出错的描述是否难以理解, 错误定位是否正确, 出错原因报告是否正确
        - 在对错误进行处理之前, 错误条件是否已经引起了系统的干预等
    - 边界测试
3. 断言: 一个简单的方法调用, 用于判断某个语句是否为真
4. Junit
    - 开源的Java测试框架, 用于单元级别测试的开放式框架
    - 目标
        - 简化测试的编写, 包括测试框架的学习和实际测试单元的编写
        - 使得单元测试保持持久性
        - 可以利用既有的测试来编写相关的测试
    - 基本接口        
        |接口|说明|
        |:--:|:--:|
        |@Test|标注需要执行的测试方法|
        |Assert|静态类, 断言方法集合, 判断代码行为结果是否和预期一致|
        |TestCase|抽象类, 定义测试方法的容器|
        |TestSuite|多个测试类的组合, 也可以包含其他的TestSuite|
        |Runner|测试执行器, 运行测试|
        |TestResult|集合任意测试的累加结果|     
    - Assert(断言)
        - 基础断言 `assertTrue(String message, boolean condition)`
        - 数值断言, 字符断言, 布尔断言, 比特断言 `assertTrue(String message, double expected, double actual, double delta)`
        - 对象断言 `assertEquals(String message, Object expected, Object actral)`
    - 基础方法
        - `setUP() tearDown()`: 在每个测试开始之前和结束之后调用, 等同与注解`@Before @After`
        - `setUpBeforeClass()/tearDownAfterClass()` : 在所有测试开始之前和结束之后调用, 等同于注解`@BeforeClass/@AfterClass(注解的方法必须为public static void *()`
        - `@Test` : 注解测试方法
            - `expected`: 期望抛出指定的异常
            - `timeout`: 指定超时时间(毫秒)
        - `@Ignore`: 注解忽略的方法
        - `Runner`: 执行引擎, 所有的测试方法由此类负责执行. 可以自定义执行引擎, `@RunWith(Suite.class)`
        - 测试套件
            - 创建空类作为测试入口
            - 导入包
            ```java
            import org.junit.runner.*;
            import org.junit.runners.Suite;
            import org.junit.runners.Suite.SuiteClasses;
            ```
            - 将`org.junit.runners.Suite`作为参数传入`RunWith`, 提示Junit为此类使用套件运行器执行
            ```java
            @RunWith(Suite.class)
            @SuiteClasses({moneyTest.class, money2Test.class})
            public class TestDemo {

            }
            ```
        - 参数化测试: 提高代码重用度
            - 指定参数化测试的运行器`org.junit.runners.Parameterized`
            - 为测试类声明几个变量, 分别用于存放期望值和测试数据
            - 为测试类声明一个使用`org.junit.runners.Parameterized.Parameters`修饰的返回`java.util.Collection`的公共静态方法, 在此方法中初始化所有需要的测试参数组
            - 为测试类声明一个带有参数的公共构造函数, 并在其中为变量赋值
            - 编写测试方法, 使用定义的变量作为参数进行测试
    - 测试覆盖率
        - 评价测试活动覆盖产品代码的指标
        - 白盒测试
        - 指标
            - 行覆盖率
            - 基本语句块覆盖率
            - 类覆盖率
            - 方法覆盖率
5. Ant
    - 实现项目自动化构件和部署
    - 默认配置文件为`build.xml`
    ```xml
    <project>
        <!-- 全局变量定义 -->
        <property/>
        <!-- 任务组 -->
        <target>
            <!-- 单任务 -->
            <task1/>
            <task2/>
        </target>
    </project>
    ```
    - `<project name="工程名称" default="默认执行的target名称" basedir="基路径位置">`
    - `<target name="targetName" depends="dependsName">`
    - `property` 定义全局变量, 通过`${name}`引用, 内置了`basedir/ant.file/ant.version`
    - `task`是可执行代码, 常用的有`javac,jar,junit,copy,delete`
    - javac
        ```xml
        <javac srcdir="${src}" destdir="${dest}">
            <classpath>
                <fileset dir="lib">
                    <include name="**/*.jar" />
            </classpath>
        </javac>
        ```
    - junit
        ```xml
        <junit>
            <test name="${testcase}" if="testcalse"/>
            <batchtest todir="${dest}" unless="testcalse">
                <fileset/>
            </batchtest>
        </junit>
        ```
    - junitreport
        ```xml
        <junitreport todir="${test.xml}">
            <fileset dir="${test.xml}">
                <include name="TEST-*.xml"/>
            </fileset>
            <report format="frames" todir="${test.report}"/>
        </junitreport>
        ```
## 功能测试
1. 概述
    - 功能测试可以发生在单元测试中, 也可以在集成测试,系统测试中进行
    - 黑盒测试
    - 主要可归为界面/数据/操作/逻辑/接口等方面
    - 目的
        - 单元测试中功能测试的目的是保证所测试的每个独立模块的功能是正确的
        - 系统集成后进行的功能测试是实现产品规格说明书上的所有功能
2. 常用技术
    - 录制回放
    - 数据驱动
    - 关键字驱动
3. 工具: QTP, Selenium
4. QTP使用流程
    - 制定测试计划
    - 录制测试脚本
    - 增强测试脚本: 插入检查点,添加测试输出信息和注释等
        - 标准检查点
        - 图像检查点
        - 表格检查点
        - 文字检查点
        - ...
    - 调试测试脚本
    - 运行测试脚本
    - 分析测试结果
5. 参数化测试
    - 数据驱动测试方法: 把数据从测试脚本中分离出来, 实现测试脚本的参数化
        - 参数化测试步骤的数据, 绑定到数据表格的某个字段
        - 编辑数据表格, 在表格中编辑多行测试数据
        - 设置迭代次数, 选择数据行, 运行测试脚本每次迭代从中选择一行数据
6. 注册用户自定义函数(RegisterUserFunc)
    - `RegisterUserFunc "WinList", "Select", "SelectRegExp"`
        - 第一个参数: 注册目的对象
        - 第二个参数: 注册到目的对象的那个方法
        - 第三个参数: 初测的脚本中那个VBS函数
        - 第四个参数: 注册的函数是否作为测试对象的默认方法(可省略)
    - `Window("Filght Reservation").Dialog("Flights Table").Activate`
    - `Window("Flight Reservation").Dialog("Flights Table").WinList("From").Select "19170.*"`
## 集成测试
1. 在单元测试的基础上将所有模块按照概要设计要求组成子系统或系统的测试, 是对模块件接口或者系统接口以及集成后的子系统或系统功能进行正确性检验的一项测试工作
2. 集成测试的关注点
    - 模块集成之后通过模块接口的交互参数数量/类型/顺序是否一致, 是否存在数据丢失
    - 模块集成之后是否存在单元测试没发现的问题
    - 子模块集成以后能否实现期望的功能
    - 在集成的过程中, 新的模块的加入是否会对已经集成的模块产生负面影响
    - 全局数据结构正确
    - 随着系统的集成, 系统的误差是否会被放大
    - 在与用户界面的集成中, 控件的输入内容检查/结果显示/数据类型控制方面是否合理
3. 集成测试的层次
    - 模块内集成
    - 子系统内集成
    - 子系统间集成
    - 不同系统之间的集成
4. 集成测试的方法
    - 基于分解的集成方法
        - 大爆炸集成
            - 非增量
            - 尽可能缩短测试使劲啊
            - 优点: 时间短, 测试用例少, 工作量小
            - 缺点: 难以保证接口,全局数据结构进行充分的测试, 错误定位困难
            - 适用: 功能少, 模块数量不多, 程序逻辑简单, 单个组件充分测试
        - 自顶向下集成
            - 增量式集成方法
            - 主模块为所测模块的驱动模块, 所有的下属模块全部用装模款
