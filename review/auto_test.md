# 自动化测试

## 软件测试
1. 定义 
    - 第一类测试: 在既定的状况条件下, 运行一个系统或者组件, 观察记录结果, 并对其某些方面进行评估的过程
    - 第二类测试: 软件测试是为了发现错误而运行程序的过程
2. 软件缺陷: 软件缺陷就是软件产品中所存在的问题, 表现为用户所需要的功能没有完全实现, 不能满足或者不能完全满足用户的需求.
3. 不同分类方法:
    - 最普遍的测试策略:
        - 黑盒测试(功能性测试或者数据驱动测试): 在测试时, 把被测程序看作一个黑盒, 在完全不考虑程序内部结构和内部特性的情况下进行
        - 白盒测试(结构测试/逻辑驱动测试/基于程序的测试): 测试时可以看到被测试的源程序, 可用于分析程序内部结构, 并且根据内部结构设计测试用例
        - 灰盒测试: 介于黑盒测试和白盒测试之间, 此种测试方法关注输出对于输入的正确性, 同时也关注内部表现
    - 新技术:
        - 基于模型的测试
        - 面向对象测试
        - Web测试
        - 敏捷测试
        - 模糊测试
## 功能性测试(黑盒)
1. 等价类划分: 将所有可能的输入数据划分为若干个等价类, 然后在每一个等价类中选择少数具有代表性的数据作为测试数据
    - 划分
        - 有效等价类: 符合规格说明要求的合理输入集合, 主要用来检验程序是否已经实现了规格说明预先规定的功能和性能
        - 无效等价类: 不符合规格说明要求的不合理输入或者非法的输入集合, 主要用来检验程序是否已经做了不符合规格说明要求的事情
    - 设计测试用例
        - 确定等价类, 列出所划分出的等价类表     
        
            | 输入条件|有效等价类|无效等价类|    
            |:--:|:--:|:--:|
            |  |  |
            |  |  |      
            
        - 利用等价类设计测试用例
    - 存在问题
        - 规格说明往往没有定义无效输入时的输出
        - 强类型语言不必考虑无效输入
2. 边界值分析
    - 边界条件: 软件计划的操作界限所在的边缘条件
    - 边界值分析设计测试用例: 通过使所有变量取正确值, 只使一个变量分别取最小值/最大值/略低于最大值/略高于最小值. 对于一个n变量的程序, 边界值分析会产生4n+1个测试用例
    - 健壮性边界测试
        - 在边界值分析测试用例的基础上, 添加 略高于最大值/略低于最小值 的两个测试用例, 共产生 6n+1个测试用例
        - 有意义的使预期的输出, 观察例外情况如何处理
    - 内部边界值
        - 数值的边界值检验        
        
            |项|范围|
            |:--:|:--:|
            |位(bit)|1或者0|
            |字节(byte)|0~255|
            |字(word)|0~65535/ 0~4294967295|
            |千(K)|1024|
            |兆(M)|1048576|
            |吉(G)|1073741824|    
            
        - 字符的边界值(ASCII/Unicode)
3. 正交分析法
    - 利用正交表安排实验方案以及实验结果
    - 步骤
        - 提取功能说明, 构造因子-状态表
        - 加权筛选, 生成因素分析表
        - 利用正交表构造测试数据集
## 结构性测试(白盒测试)
1. 基于覆盖的测试
2. 语句覆盖: 设计若干个测试用例, 运行被测程序, 使得每一条可执行语句至少执行一次. 最弱的逻辑覆盖准则
3. 分支覆盖: 设计若干个测试用例, 运行被测程序, 使得每个判断的真分支和假分支至少执行一次. 
4. 条件覆盖: 设计若干个测试用例, 运行被测程序, 使得程序中每个判断的每个条件的可能取值至少执行一次
5. 分支条件覆盖: 设计足够的测试用例, 使得判断中每个条件的所有可能取值至少执行一次, 同时每个判断的所有可能判断结果至少执行一次, 即要求各个判断的所有可能的条件组合至少执行一次
6. 条件组合覆盖: 设计足够的测试用例, 运行被测程序, 使得每一个判断的所有可能的条件取值组合至少执行一次
7. 路径覆盖: 选取足够的测试用例, 覆盖被测试程序中的所有可能路径
8. 基本路径测试: 在程序控制流图的基础上, 通过分析控制构造的环形复杂性, 导出基本可执行路径集合, 从而设计测试用例的方法
    - 程序流图
    - 程序圈复杂度
    - 独立路径和独立路径基本集合
    - 准备测试用例
## 静态分析
1. 控制流分析
2. 数据流分析
3. 接口分析
4. 表达式分析
    - 除零异常
    - 开方负数
    - 浮点数的直接比较
    - 算数溢出
    - 数组越界
    - 数组引用错误
5. 代码检查
## 动态分析
1. 内存错误和内存泄漏
2. 常见的运行错误
    - 空指针带来的错误
    - 编译器截断处理带来的问题
    - 难以发现的数据溢出
    - 使用已经消亡的对象
    - 计算机体系不同潜藏的错误
    - 判断语句中执行顺序带来的隐患
    - 具有副作用语句带来的问题(自增/赋值)
    - ...
## 软件测试准则
1. 需求阶段
    - 需求检查: 编写测试用例之前, 需要对每个需求建立质量测度标准, 确保正确和没有需求遗漏, 将模糊的需求明确化
    - 设计测试过程, 响应需求变化
        - 单项测试需求内容, 用容易理解的自然语言, 明确的描述需要测试的内容
        - 多项测试内容, 应尽可能的剥离开来, 保证一条测试需求只包含一项测试内容
2. 测试计划的编制和测试文档
    - 测试内容
    - 测试实施方案
    - 测试步骤
    - 测试环境
    - 测试进度计划
    - 测试风险分析和应急对策
    - 测试策略
    - 测试交付清单
3. 测试设计
    - 测试用例设计(核心)
    - 测试场景设置
4. 测试执行和问题跟踪
    - 测试环境搭建
    - Bug记录与跟踪
5. 测试报告
    - 测试开发完成时编写, 对项目实施情况/项目质量/项目中遇到的问题以及解决措施进行总结分析, 从中吸取经验教训
6. 测试流程和过程的区别
    - 软件测试过程一般指的是具体的测试执行过程, 包括单元测试/集成测试/确认测试/系统测试/验收测试
    - 流程强调的是做事情的逻辑, 活动的线路
    - 软件测试不管采取什么流程进行, 都存在过程和结果
    - 过程和流程是对同一事物不同级别的描述, 并不是包含关系. 过程抓大放小, 流程事无巨细. 高层管理者重视全程的全面把握和对关键点的监督. 中层管理者以及一线的工作人员, 要严格遵守流程规范, 按流程规定的时间/入口准则/使用的技术方法/出口准则等, 完成软件开发的各项工作
## 自动化软件测试
1. 手工测试的局限性
    - 无法覆盖所有的代码路径
    - 功能性测试具有 机械性/重复性/工作量大 的特点
    - 许多错误通过手工测试很难捕捉到(多线程/死锁/资源冲突)
    - 需要模拟大量数据或者大量并发用户等各种场景时, 很难通过手工测试进行
    - 验证系统稳定性时, 手工测试无法模拟
    - 测试用例巨大, 手工测试无法短时间完成
2. 测试自动化
    - 自动化测试相对于手工测试而存在
    - 模拟手工测试步骤, 通过执行由程序语言编制的测试脚本, 自动地完成一切测试任务的工作
    - "一切" 不仅仅指的是测试执行的工作, 还包括测试的其他工作, 如缺陷管理/测试管理/环境安装/设置/维护
3. 自动化测试优势
    - 缩短周期
    - 速度/效率/准确可靠/不知疲倦
    - 节省人力成本, 降低测试成本
    - 做手工不能做
4. 自动化测试不足
    - 不能完全代替手工测试和手工测试工程师
    - 不能保障100%覆盖率
    - 不能弥补测试实践的不足
5. 自动化测试的原理和方法
    - 代码分析
        - 检查编码规范
        - 根据某种质量模型评价代码质量与复杂度
        - 一种白盒测试的自动化方法
    - 捕捉和回放
        - 一种黑盒测试的自动化方法
        - 记录用户的每一步操作, 将记录转换为脚本语言描述的过程, 模拟用户操作
        - 回放是将脚本记录的操作转换为屏幕上的操作, 记录系统的输出记录
        - 记录方式有两种: 程序用户界面的像素坐标或程序显示对象的位置, 以及相对应的操作/状态变化/属性变化
    - 脚本技术: 脚本是测试工具执行的指令集合, 也是计算机程序的一种形式
        - 线性脚本: 录制手工操作而得到的脚本
        - 结构化脚本: 类似于结构化程序设计, 具有各种逻辑结构/函数调用功能
        - 数据驱动脚本: 将测试脚本和数据分离, 测试输入数据存储在独立的文本中
        - 关键字驱动脚本: 数据驱动脚本的逻辑扩张, 封装了各种基本的操作, 每个操作由相应的函数实现
    - 自动比较
        - 运行测试脚本时, 对执行过程中的输出数值与期望数值自动比较
        - 两类比较模式
            - 验证(Verify): 失败时测试继续运行
            - 断言(Assert): 失败时退出当前测试
6. 测试工具的作用和优势
    - 作用
        - 测试自动化需要借助测试工具
        - 测试工具可以进行部分的侧式设计/实现/执行/比较工作
        - 常用的工作方式为 人工设计测试用例, 使用工具进行用例的执行和比较
    - 优势
        - 记录业务流程并生成脚本程序的能力
        - 对各种网络设备的模仿能力
        - 用有限的的资源生成高质量虚拟用户的能力
        - 对于真个软件和硬件系统中各个部分的监控能力
        - 对于测试结果的表现和分析能力

## 静态测试
1. 定义: 基于期望属性/专业经验/通用标准来对工作件的特性进行详细检查的一种测试方法
    - 工作件: 指的是静态测试的对象, 是不同种类产品的交付件, 即一切项目过程文档
2. 特性:
    - 查错和分析功能是其他测试方法不能替代的
    - 目的是今早发现和处理工作件中的缺陷
    - 寻找三类缺陷: 错误 遗漏 额外
3. 方法
    - 代码审查
        - 在编译和动态测试之前
        - 识别和消除安全缺陷
        - 有赖于程序员的经验和韧性
        - 需要自动化工具补充
        - 效率高(30%-70%的逻辑设计和编码缺陷)
    - 文档审查
        - 需求文档中的字段缺失, 描述错误, 错别字等
        - 设计错误, 不完善, 遗漏问题
        - 需求问题
4. 编码规范
    - ISO C(C11)
    - MISRC
    - C具体规范
        - 数据类型相关
            - 类型转换
            - 指针的安全规范
            - 指针的有效性
            - 结构体和联合体
        - 防范表达式失控
        - 准确的程序流程控制
            - 布尔表达式不应出现赋值操作
            - 显式的判断一个值是否为0
            - 浮点表达式不能直接比较
            - switch表达式应该以break结束
        - 构建安全的编译环境
            - 函数的定义和声明: 头文件中不允许包含可执行代码
            - 预处理: 文件中的`#include`语句之前只能是其他预处理指令或注释; C的宏定义中, 任何一个参数都应该加小括号
5. PC-Lint
    - 静态代码分析工具, 命令行工具, 能够检测出许多语法逻辑上的隐患, 而且也能有效的提出许多程序在空间利用/运行效率上的改进点
    - 功能
        - 检测单个文件
        - 从整个项目角度检测问题
        - 支持很多流行的编辑环境
        - 支持<<Effective C++>>中描述的各种提高效率和防止错误的方法
    - 基本使用
        - `lint-nt.ext -u -id:\lint std.lnt sample.c`
            - `-u`表示只对本单元检查
            - `-i`指定搜索文件目录
            - `std.lnt`表示要使用的配置文件
            - `sample.c`表示待检查的源文件, 支持通配符`*`
        - 常用选项      
        
            |选项|功能|
            |:--:|:--:|
            |-i|设置`include`路径|
            |-e#|屏蔽告警, `-e200`:屏蔽200号警告|
            |-esym(#, 符号名)|屏蔽符号名对应的告警, `-esym(39, std)`,屏蔽39号的std告警|
            |-emacro(#, 宏名称)|屏蔽宏警告|     
            
        - 警告分类
            - 编号<1000的为C语言, 大于的为C++
            - 信息表
                |错误说明|C|C++|警告级别|
                |:--:|:--:|:--|:--:|
                |语法错误|1-199|1001-1199|1|
                |内部错误|200-299||0|
                |致命错误|300-399||0|
                |警告|400-699|1400-1699|2|
                |消息|700-899|1700-1899|3|
                |可选信息|900-999|1900-1999|4|
            - C++的错误说明与C语言相同, 内部错误和知名错误共享
        - 警告级别       
        
            |级别|信息|
            |:--:|:--:| 
            |-w0|不产生信息, 除非致命错误|
            |-w1|只生成错误信息, 屏蔽警告和其他提示信息|
            |-w2|只有警告和错误|
            |-w3|默认配置, 生成警告/错误/提示信息|
            |-w4|生成所有信息|     
            
        - 库函数头文件信息级别       
        
            |级别|信息|  
            |:--:|:--:|
            |-wlib(0)|不生成任何库信息|
            |-wlib(1)|生成错误信息|
            |-wlib(2)|生成错误和警告信息|
            |-wlib(3)|生成错误/警告/提示消息(默认配置)|
            |-wlib(4)|生成所有信息|      
            
        - 检查种类
            - 强类型检查
                - `-strong`&`-index`可以对typeof定义的数据类型进行强类型检查
                - `strong(flags[,name]...)`
                - 选项必须在`typeof`定义之前打开
                - `flag`参数
                    - A : 对强类型变量赋值时进行类型检查
                        - i: 忽略初始化
                        - r: 忽略return
                        - p: 忽略参数传递
                        - a: 忽略赋值操作
                        - c: 忽略常量赋值
                        - z: 忽略zero赋值
                    - X : 当把强类型变量赋值给其他变量时进行类型检查
                    - J: 强类型与其他类型进行运算时检查
                        - e: 忽略 `==` `!=` `?:`
                        - r: 忽略 `>=` `>` `<` `<=`
                        - o: 忽略 `+.-.*./.%.|.^.&`
                        - c: 忽略强类型与常量运算时检查
                        - z: 忽略强类型与0运算时检查
                    - B: bool类型
                    - Tips:
                        - A和J选项的弱化字符必须紧跟之后
                        - B和b不能同时使用
                        - f必须与B或者b一起使用
                        - `-strong`的作用仅仅时声明type为强类型而不做任何检查
            - 变量值跟踪
                - 对变量值的初始化进行跟踪
                - 对应编号
                    - 644,645 变量可能没有初始化
                    - 771,772 变量不可靠的初始化
                    - 530 变量未初始化
                    - 1401-1403 成员未初始化
                - 默认函数的参数在正确范围内
            - 语义信息
            - 赋值顺序检查
                - 当一个表达式的值依赖于赋值顺序时, 告警(564) ``` a[i]=i++;func(i++,n+i);```
            - 格式检查
            - 缩进检查
            - const变量检查
            - volatile变量检查
            - 弱定义检查
        - 选项
            - 选项间空格分隔, 小写, 紧跟`/*`或者`//`
            - 选项可以放在宏定义之中, 在宏中的注释字数必须小于80
                - `#define DIVZERO(x) /*lint -save -e54 */((x)/0) /*lint -restore */`
## 单元测试
1. 单元测试是针对程序模块, 进行正确性检验的测试. 其目的在于发现各模块内部可能存在的各种差错,
2. 主要内容
    - 模块内部逻辑结构测试
    - 局部数据结构测试
    - 测试策略: 白盒测试
    - 错误处理测试: 检查模块的错误处理功能是否含有错误或缺陷
        - 是否拒绝不合理的输入
        - 出错的描述是否难以理解, 错误定位是否正确, 出错原因报告是否正确
        - 在对错误进行处理之前, 错误条件是否已经引起了系统的干预等
    - 边界测试
3. 断言: 一个简单的方法调用, 用于判断某个语句是否为真
4. Junit
    - 开源的Java测试框架, 用于单元级别测试的开放式框架
    - 目标
        - 简化测试的编写, 包括测试框架的学习和实际测试单元的编写
        - 使得单元测试保持持久性
        - 可以利用既有的测试来编写相关的测试
    - 基本接口        
    
        |接口|说明|
        |:--:|:--:|
        |@Test|标注需要执行的测试方法|
        |Assert|静态类, 断言方法集合, 判断代码行为结果是否和预期一致|
        |TestCase|抽象类, 定义测试方法的容器|
        |TestSuite|多个测试类的组合, 也可以包含其他的TestSuite|
        |Runner|测试执行器, 运行测试|
        |TestResult|集合任意测试的累加结果|     
        
    - Assert(断言)
        - 基础断言 `assertTrue(String message, boolean condition)`
        - 数值断言, 字符断言, 布尔断言, 比特断言 `assertTrue(String message, double expected, double actual, double delta)`
        - 对象断言 `assertEquals(String message, Object expected, Object actral)`
    - 基础方法
        - `setUP() tearDown()`: 在每个测试开始之前和结束之后调用, 等同与注解`@Before @After`
        - `setUpBeforeClass()/tearDownAfterClass()` : 在所有测试开始之前和结束之后调用, 等同于注解`@BeforeClass/@AfterClass(注解的方法必须为public static void *()`
        - `@Test` : 注解测试方法
            - `expected`: 期望抛出指定的异常
            - `timeout`: 指定超时时间(毫秒)
        - `@Ignore`: 注解忽略的方法
        - `Runner`: 执行引擎, 所有的测试方法由此类负责执行. 可以自定义执行引擎, `@RunWith(Suite.class)`
        - 测试套件
            - 创建空类作为测试入口
            - 导入包
            ```java
            import org.junit.runner.*;
            import org.junit.runners.Suite;
            import org.junit.runners.Suite.SuiteClasses;
            ```
            - 将`org.junit.runners.Suite`作为参数传入`RunWith`, 提示Junit为此类使用套件运行器执行
            ```java
            @RunWith(Suite.class)
            @SuiteClasses({moneyTest.class, money2Test.class})
            public class TestDemo {

            }
            ```
        - 参数化测试: 提高代码重用度
            - 指定参数化测试的运行器`org.junit.runners.Parameterized`
            - 为测试类声明几个变量, 分别用于存放期望值和测试数据
            - 为测试类声明一个使用`org.junit.runners.Parameterized.Parameters`修饰的返回`java.util.Collection`的公共静态方法, 在此方法中初始化所有需要的测试参数组
            - 为测试类声明一个带有参数的公共构造函数, 并在其中为变量赋值
            - 编写测试方法, 使用定义的变量作为参数进行测试
    - 测试覆盖率
        - 评价测试活动覆盖产品代码的指标
        - 白盒测试
        - 指标
            - 行覆盖率
            - 基本语句块覆盖率
            - 类覆盖率
            - 方法覆盖率
5. Ant
    - 实现项目自动化构件和部署
    - 默认配置文件为`build.xml`
    ```xml
    <project>
        <!-- 全局变量定义 -->
        <property/>
        <!-- 任务组 -->
        <target>
            <!-- 单任务 -->
            <task1/>
            <task2/>
        </target>
    </project>
    ```
    - `<project name="工程名称" default="默认执行的target名称" basedir="基路径位置">`
    - `<target name="targetName" depends="dependsName">`
    - `property` 定义全局变量, 通过`${name}`引用, 内置了`basedir/ant.file/ant.version`
    - `task`是可执行代码, 常用的有`javac,jar,junit,copy,delete`
    - javac
        ```xml
        <javac srcdir="${src}" destdir="${dest}">
            <classpath>
                <fileset dir="lib">
                    <include name="**/*.jar" />
            </classpath>
        </javac>
        ```
    - junit
        ```xml
        <junit>
            <test name="${testcase}" if="testcalse"/>
            <batchtest todir="${dest}" unless="testcalse">
                <fileset/>
            </batchtest>
        </junit>
        ```
    - junitreport
        ```xml
        <junitreport todir="${test.xml}">
            <fileset dir="${test.xml}">
                <include name="TEST-*.xml"/>
            </fileset>
            <report format="frames" todir="${test.report}"/>
        </junitreport>
        ```
## 功能测试
1. 概述
    - 功能测试可以发生在单元测试中, 也可以在集成测试,系统测试中进行
    - 黑盒测试
    - 主要可归为界面/数据/操作/逻辑/接口等方面
    - 目的
        - 单元测试中功能测试的目的是保证所测试的每个独立模块的功能是正确的
        - 系统集成后进行的功能测试是实现产品规格说明书上的所有功能
2. 常用技术
    - 录制回放
    - 数据驱动
    - 关键字驱动
3. 工具: QTP, Selenium
4. QTP使用流程
    - 制定测试计划
    - 录制测试脚本
    - 增强测试脚本: 插入检查点,添加测试输出信息和注释等
        - 标准检查点
        - 图像检查点
        - 表格检查点
        - 文字检查点
        - ...
    - 调试测试脚本
    - 运行测试脚本
    - 分析测试结果
5. 参数化测试
    - 数据驱动测试方法: 把数据从测试脚本中分离出来, 实现测试脚本的参数化
        - 参数化测试步骤的数据, 绑定到数据表格的某个字段
        - 编辑数据表格, 在表格中编辑多行测试数据
        - 设置迭代次数, 选择数据行, 运行测试脚本每次迭代从中选择一行数据
6. 注册用户自定义函数(RegisterUserFunc)
    - `RegisterUserFunc "WinList", "Select", "SelectRegExp"`
        - 第一个参数: 注册目的对象
        - 第二个参数: 注册到目的对象的那个方法
        - 第三个参数: 初测的脚本中那个VBS函数
        - 第四个参数: 注册的函数是否作为测试对象的默认方法(可省略)
    - `Window("Filght Reservation").Dialog("Flights Table").Activate`
    - `Window("Flight Reservation").Dialog("Flights Table").WinList("From").Select "19170.*"`
## 集成测试
1. 在单元测试的基础上将所有模块按照概要设计要求组成子系统或系统的测试, 是对模块件接口或者系统接口以及集成后的子系统或系统功能进行正确性检验的一项测试工作
2. 集成测试的关注点
    - 模块集成之后通过模块接口的交互参数数量/类型/顺序是否一致, 是否存在数据丢失
    - 模块集成之后是否存在单元测试没发现的问题
    - 子模块集成以后能否实现期望的功能
    - 在集成的过程中, 新的模块的加入是否会对已经集成的模块产生负面影响
    - 全局数据结构正确
    - 随着系统的集成, 系统的误差是否会被放大
    - 在与用户界面的集成中, 控件的输入内容检查/结果显示/数据类型控制方面是否合理
3. 集成测试的层次
    - 模块内集成
    - 子系统内集成
    - 子系统间集成
    - 不同系统之间的集成
4. 集成测试的方法
    - 基于分解的集成方法
        - 大爆炸集成
            - 非增量
            - 尽可能缩短测试使劲啊
            - 优点: 时间短, 测试用例少, 工作量小
            - 缺点: 难以保证接口,全局数据结构进行充分的测试, 错误定位困难
            - 适用: 功能少, 模块数量不多, 程序逻辑简单, 单个组件充分测试
        - 自顶向下集成
            - 增量式集成方法
            - 主模块为所测模块的驱动模块, 所有的下属模块全部用桩模块对主模块进行测试
            - 优点
                - 较早验证主要的控制和判断模块
                - 选择深度优先, 可以首先实现和验证一个完整的功能
                - 不需要开发驱动器, 减少开发和维护成本
                - 开发和集成测试的顺序一致, 可以并行
            - 缺点
                - 叶子模块一般是实现功能, 桩模块可能影响全局模块
                - 底层模块的加入, 整个系统复杂度增加, 重用或被多个模块调用的模块测试不充分
            - 适用于采用结构化编程方法的软件产品
        - 自底向上
    - 混合策略
        - 三明治集成: 对软件结构中的较上层, 使用的是自顶向下法, 对软件结构中较下层, 使用自底向上法, 两者相结合
            - 优点: 将自顶向下和自底向上的集成方法有机的结合起来, 不需要写桩程序, 因为在测试初, 自底向上集成已经验证了底层模块的正确性
            - 缺点: 最后的所有模块集成阶段会增加缺陷定位的难度
            - 适用与大多数软件系统
    - 集成策略对比

        ||自底向上|自顶向下|混合策略|大爆炸|
        |:--:|:--:|:--:|:--:|:--:|
        |集成|早|早|早|晚|
        |基本程序能工作时间|晚|早|早|晚|
        |需要驱动程序|是|否|是|否|
        |需要桩程序|否|是|是|否|
        |工作并行性|中|低|高||
        |计划与控制|容易|难|稍难|容易|

    - 基于调用图的集成
        - 成对集成和相邻集成
        - 相邻是针对模块节点而言的, 模块节点的邻居指向有向图中该节点的所有直接前驱结点和后继节点
        - 汇节点是程序执行结束处的语句片段
    - 基于MM路径的集成测试
        - MM路径: 模块执行路径与消息交互序列
        - 源节点: 单元中第一个可执行语句, 或转移控制到其他单元节点之后的紧接着的节点
        - 汇节点: 单元中的最后一个可执行语句, 或转移控制到其他单元的节点
## 面向对象软件的测试
1. 特征
    - 以对象为核心
    - 数据和操作数据的方法一起构成了不可见的单元
    - 多态,继承和封装
2. 类与子类的测试
    - 通常采用自顶向下的方法: 高层类着重通用接口和代码的测试, 针对每一个子类生成专门的测试驱动代码
    - 分层与增量
3. 面向对象的单元测试
    - 区别: 传统单元测试对象--模块, 面向对象单元测试--类, 但需要考虑该类满足的继承和多态的要求
    - 方法
        - 通过代码检查或执行测试用例能有效的测试一个类的代码
            - 代码检测容易受认为错误的影响, 而且工作量大, 需要测试驱动程序
            - 测试驱动程序是一个运行测试用例并且收集运行结果的程序, 必须是严谨的, 结构清晰, 简单, 易于维护
    - 确定组成部分
        - 类在系统中的作用, 尤其是与之相关的风险程度
        - 类的复杂性
        - 开发这个类测试驱动程序所需的工作量
    - 有限状态机(FSM): 表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型
    - 常用的测试方法
        - 随机测试
        - 划分测试
            - 基于状态的划分
            - 基于属性的划分
            - 基于操作类别的划分
            - 
    - 构建测试用例的总体思想
        - 为所有可能出现的组合情况确定测试用例需求
        - 创建测试用例来表达这些需求, 包括特定的输入值(边界值), 并确定他们的正确输出
        - 增加测试用例来阐述违反前置条件所发生的情况
    - 类测试(覆盖率)常用标准
        - 基于约束的覆盖率, 有多少对前置/后置条件被覆盖来表示充分性
        - 基于代码的覆盖率. 当所有的测试用例都执行结束时, 确定实现一个类的每一行代码或代码通过的每一条路径至少执行了一次
4. 面向对象的集成测试
    - 类的线性测试, 交互测试
        - 汇集类测试
        - 协作类测试
    - 类的独立性测试(跨平台方面测试)
    - Uml测试: 可通过应用随机方法以及基于use-case场景和行为模型导出测试用例
5. 面向对象的集成测试- 分布对象测试
    - 在类(产生分布式对象的类)的层次上进行更彻底的测试
    - 在记录事件发生顺序的同时, 执行大量的测试用例
    - 制定标准的测试环境
## 回归测试和非功能测试
1. 回归测试
    - 回归测试指的是缺陷修改之后, 重新进行测试以保证修改的正确性, 即确认修改没有引入新的错误或者导致其他代码产生错误
    - 回归测试并不是一个测试级别, 但却是各个级别必须包含的一个测试活动
    - 测试策略
        - 从测试用例库中选择有效的测试用例, 构造一个缩减的测试用例组来完成回归测试
            - 识别出软件中被修改的部分
            - 从测试用例库中排除不再适用的测试用例, 确定对新的软件版本依然有效的测试用例, 建立一个新的基线测试用例库
            - 根据一定的策略从新的测试用例库中选择测试用例测试修改后的软件(基于风险的策略, 分析和修改相关风险)
            - 如果回归测试包不能达到所需的覆盖要求, 必须补充新的测试用例使覆盖率达到规定的要求, 生成新的测试用例集合, 用于测试旧的用例集无法充分测试的软件部分
            - 用新的测试用例集合测试修改后的软件
2. 非功能性测试
    - 系统测试
        - 将经过集成测试后的软件作为计算机系统的一部分, 与计算机硬件,某些支持软件, 数据和人员等系统元素结合起来, 在实际运行环境下对计算机进行一系列严格有效的测试来发现软件的潜在问题, 保证系统的运行
        - 压力, 容量和性能等非功能测试常常被看作系统测试的一部分
        - 采用负载测试技术
        - 常使用特定的测试工具来模拟超常的数据量或者其他各种负载, 监视系统的各项性能指标, 如线程/CPU/内存的使用情况, 响应时间, 数据传输量等
    - 性能测试
        - 性能测试主要检验软件是否达到需求规格说明书中规定的各类性能指标, 并满足一些性能相关的约束和限制条件.
        - 目的是验证系统能否达到用户提出的性能指标, 同时发现系统中存在的性能瓶颈, 起到优化系统的作用
    - 系统性能测试的指标和基本过程
        - 系统负载: 并发用户并发数量+思考时间+每次请求发送的数据量+负载模式
        - 系统性能指标
            - 请求响应时间: 从发起请求到客户端接收到最后一个字节所耗费的时间
            - 事物响应时间: 事物可能由一系列的请求组成, 指的是完成这些请求处理所花费的时间
            - 数据吞吐量: 单位时间内客户端和服务器之间网络上传输的数据量
    - 性能测试的方法和技巧
        - 两种负载类型
            - flat测试: 对于一次给定的测试, 取响应时间和吞吐量的平均值, 精确的获得这些值的唯一方法是一次性加载所有的用户, 然后在预定的时间段内持续运行
            - ramp-up测试: 用户交替上升. 看出随着系统负载的改变, 测量值是如何改变的
        - 企业级系统性能测试方法
            - 基准测试
            - 性能规划测试
            - 渗入测试
            - 峰谷测试
        - 压力测试
            - 并发性能测试
                - 考察客户端应用的性能, 测试的入口时客户端
                - 测试的过程, 是一个负载测试和压力测试的过程
                - 逐渐增加并发虚拟用户数负载, 直到系统瓶颈
            - 疲劳强度测试
            - 大数据量测试