### Java Map
1. HashMap 在1.7- 是数组加链表实现, 1.8 是数组+链表+红黑树 , 当链表长度大于8时转为红黑树
2. HashTable 锁住整个表, SynchronizedMap 同步代码块
3. ConcurrentHashMap 
    - 1.7- 分段锁, 大大提高了高并发环境下的处理能力. 由于不是对整个Map加锁, 所以一些需要扫描整个Map的方法(size())等需要特殊实现, clear甚至放弃了对一致性的要求. 
    - 1.8+ 使用CAS算法, 底层使用 数组+链表+红黑树 实现, 同时增加了许多辅助类
        - `sizeCtl`: 负数代表正在进行初始化或者扩容, -1 表示初始化, -N表示N-1个线程正在进行扩容操作, 正数表示还没有被初始化, 下一次扩容的大小, 此值始终是当前哈希表的0.75倍, 即与`loacfactor`对应
2. mysql lock/Cartesian/聚簇索引
    1. 锁:
        - Mysql的锁主要有行锁/表锁/页锁/乐观锁/悲观锁, 不同的引擎支持的锁特性如下:

        ||行锁|表锁|页锁|
        | :-- | :--: | :--: | :--: |
        |MyISAM||√||
        |BDB||√|√|
        |InnoDB|√|√||
        - 表锁: 开销小, 加锁快, 不会出现死锁; 锁定力度大, 发生冲突概率高, 并发度最低
        - 行锁: 开销大, 加锁慢, 会出现死锁; 锁定力度小, 发生锁冲突的概率低, 并发度高
        - 页锁: 开销和加锁速度介于表锁和行锁之间; 会出现死锁, 锁定力度介于表锁和行锁之间
    2. 笛卡儿积: 多表查询时记录之间组合
    3. 索引: 
        - 索引是帮助MySQL高效获取数据的数据结构
        - 优势: 1. 提高数据检索效率,减少数据库的IO成本  2. 通过索引对数据进行排序, 降低数据排序的成本, 降低了CPU的消耗
        - 劣势: 索引也是一张表, 保存了主键与索引字段, 并指向实体表的记录, 所以索引也需要占用额外的空间. 同时, 虽然大大提高了查询的速度, 但是降低了更新表的速度, 因为更新表时, MySQL不仅需要保存数据, 还需要保存索引文件
        - 常见索引: 
            - 普通索引(INDEX)
            - 唯一索引(UNIQUE): 索引列的值必须唯一, 但允许有空值
            - 主键索引(PRIMARY): 特殊的唯一索引, 不允许有空值
            - 全文索引(FULLTEXT):
            - 组合索引
        - MySQL索引结构
             - B+Tree索引(InnoDB, MySIAM)
             - Hash索引
        - 聚簇索引: 
            - MyISAM非聚簇索引, 主索引和辅助索引没有本质区别, 叶子节点存储数据存放的地址.
            - InnoDB聚簇索引, 数据文件本身就是索引文件, 叶子节点的data就是数据本身. 所以检索的时候若是主键则直接索引, 非主键先检索主键, 然后检索整条纪录

3. 微服务
4. jvm
5. 事务/aop/ioc/测试
6. JIT
7. transient 不需要序列化
8. 嵌套`synchronized`死锁
9. volatile