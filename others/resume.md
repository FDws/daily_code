### Java Map
1. HashMap 在1.7- 是数组加链表实现, 1.8 是数组+链表+红黑树 , 当链表长度大于8时转为红黑树
2. HashTable 锁住整个表, SynchronizedMap 同步代码块
3. ConcurrentHashMap 
    - 1.7- 分段锁, 大大提高了高并发环境下的处理能力. 由于不是对整个Map加锁, 所以一些需要扫描整个Map的方法(size())等需要特殊实现, clear甚至放弃了对一致性的要求. 
    - 1.8+ 使用CAS算法, 底层使用 数组+链表+红黑树 实现, 同时增加了许多辅助类
        - `sizeCtl`: 负数代表正在进行初始化或者扩容, -1 表示初始化, -N表示N-1个线程正在进行扩容操作, 正数表示还没有被初始化, 下一次扩容的大小, 此值始终是当前哈希表的0.75倍, 即与`loacfactor`对应
### MySQL
1. 锁:
    - Mysql的锁主要有行锁/表锁/页锁/乐观锁/悲观锁, 不同的引擎支持的锁特性如下:

    ||行锁|表锁|页锁|
    | :-- | :--: | :--: | :--: |
    |MyISAM||√||
    |BDB||√|√|
    |InnoDB|√|√||
    - 表锁: 开销小, 加锁快, 不会出现死锁; 锁定力度大, 发生冲突概率高, 并发度最低
    - 行锁: 开销大, 加锁慢, 会出现死锁; 锁定力度小, 发生锁冲突的概率低, 并发度高
    - 页锁: 开销和加锁速度介于表锁和行锁之间; 会出现死锁, 锁定力度介于表锁和行锁之间
2. 笛卡儿积: 多表查询时记录之间组合
3. 索引: 
    - 索引是帮助MySQL高效获取数据的数据结构
    - 优势: 1. 提高数据检索效率,减少数据库的IO成本  2. 通过索引对数据进行排序, 降低数据排序的成本, 降低了CPU的消耗
    - 劣势: 索引也是一张表, 保存了主键与索引字段, 并指向实体表的记录, 所以索引也需要占用额外的空间. 同时, 虽然大大提高了查询的速度, 但是降低了更新表的速度, 因为更新表时, MySQL不仅需要保存数据, 还需要保存索引文件
    - 常见索引: 
        - 普通索引(INDEX)
        - 唯一索引(UNIQUE): 索引列的值必须唯一, 但允许有空值
        - 主键索引(PRIMARY): 特殊的唯一索引, 不允许有空值
        - 全文索引(FULLTEXT):
        - 组合索引
    - MySQL索引结构
         - B+Tree索引(InnoDB, MySIAM)
         - Hash索引
    - 聚簇索引: 
        - MyISAM非聚簇索引, 主索引和辅助索引没有本质区别, 叶子节点存储数据存放的地址.
        - InnoDB聚簇索引, 数据文件本身就是索引文件, 叶子节点的data就是数据本身. 所以检索的时候若是主键则直接索引, 非主键先检索主键, 然后检索整条纪录
4. 范式:
    - 范式可以理解一张数据表的表结构所符合的某种设计标准的级别
    - 第一范式`1NF`: 符合第一范式的关系中的属性都不可再分. 有四个问题:
        - 数据冗余过大
        - 插入异常
        - 删除异常
        - 修改异常
    - 第二范式`2NF`:在第一范式的基础上, 消除了非主属性对码的部分函数依赖
        - 函数依赖: 在一张表中, 若在属性(组)A确定的情况下必定能确定属性B的值, 则称B函数依赖于A, 记作`A -> B`
            - 完全函数依赖: 属性组A可以确定B, 属性组A的真子集不能确定, 则称B对于A完全函数依赖
            - 部分函数依赖: 属性组A的部分属性即可确定B, 称B部分函数依赖于A
            - 传递函数依赖: 若C函数依赖于B, B函数依赖于A, B不包含于A且A不函数依赖于B, 则称C传递依赖于A
        - 码: 设K为表中的一个属性或者属性组, 若除K外的所有属性**完全**函数依赖于K, 则称K为候选码, 简称为码. 一张表中可以有多个码, 通常选一个作为主码
        - 主属性: 包含在任意一个码中的属性称为主属性
        - 模式分解: 将大数据表拆分成多个小数据表, 使之符合更高一级范式的要求, 这个过程叫模式分解
    - 第三范式`3NF`: 在第二范式的基础上, 消除非主属性对码的传递函数依赖
        - 符合3NF设计的数据库设计, **基本**消除了数据冗余过大, 插入异常, 删除异常, 修改异常的问题 .
    - 巴斯范式`BCNF`: 在第三范式的基础上, 消除主属性对码的部分或者传递函数依赖
5. 事务:
    - READ_UNCOMMIT: 读取未提交数据, 最低层次
    - READ_COMMIT: 读取提交数据, 避免脏读, 可能导致不可重复读和幻读
    - REPEATABLE READ: 可重复读
    - SERIALIZABLE: 序列化, 避免所有问题, 但是可能导致性能下降
6. 引擎:
    - InnoDB: 支持事务, 支持外键, 聚集索引, 不保存行数, 不支持全文索引
    - MyISAM: 不支持事务, 不支持外键, 非聚集索引, 保存行数, 支持全文索引
### 设计模式
1. 工厂模式 : 单独的工厂类来负责创建实例
2. 抽象工厂模式 : 产品之间的抽象关系
3. 建造者模式
4. 原型模式
5. 单例模式
6. 适配器模式
7. 桥接模式
8. 组合模式
9. 装饰模式
10. 外观模式
11. 享元模式
12. 代理模式
13. 解释器模式
14. 模板方法
15. 责任链模式
16. 命令模式
17. 迭代器模式
18. 中介者模式
19. 备忘录模式
20. 观察者模式
21. 状态模式
22. 策略模式
23. 访问者模式
### 计算机网络:
1. 分层体系结构:
    - OSI七层:  应用层 <- 表示层 <- 会话层 <- 运输层 <- 网络层 <- 数据链路层 <- 物理层
    - TCP/IP四层: 应用层 <- 运输层 <- 网际层 <- 数据链路层
    - 五层: 应用层 <- 运输层 <- 网络层 <- 数据链路层 <- 物理层
    - 优点:
        - 各层独立, 只通过层间接口交互
        - 灵活, 只要交互接口不变就不会导致层变化
        - 各层采用最合适的技术不必考虑其他层
        - 有利于促进标准化
2. 三次握手:
    - 客户端 -> (SYN=1, seq=x) -> 服务器
    - 客户端 <- (SYN=1, seq = y, ack=x+1) <- 服务器
    - 客户端 -> (ACK=1, seq = x+1, ack = y+1) -> 服务器
3. 四次挥手:
    - 客户端 -> (FIN M ) -> 服务器
    - 客户端 <- (ack M+1) <- 服务器
    - 客户端 <- (FIN N) <-服务器
    - 客户端 -> (ACK=1, ack=K+1) -> 服务器
### 算法:
1. 时间复杂度: 一个定量描述算法运行时间的函数
### 进程与线程:
1. 进程: 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动, 进程是系统进行资源分配和调度的一个独立单位
2. 线程: 线程是进程的一个实体, 是CPU调度和分派的基本单位, 是比进程更小的能独立运行的基本单位. 线程自己基本上不拥有系统资源
3. 线程通信:
    - 同步, `synchronized`
    - `while`轮询
    - `wait/notify`机制
    - 管道通信
4. 进程通信:
    - 管道及有名管道
    - 信号量
    - 消息队列
    - 共享内存
    - 套接字
### Others
3. 微服务
4. jvm
5. 事务/aop/ioc/测试
6. JIT
7. transient 不需要序列化
8. 嵌套`synchronized`死锁
9. volatile