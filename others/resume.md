# 基础知识整理

## Java Map
1. HashMap 在1.7- 是数组加链表实现, 1.8 是数组+链表+红黑树 , 当链表长度大于8时转为红黑树
2. HashTable 锁住整个表, SynchronizedMap 同步代码块
3. ConcurrentHashMap
    - 1.7- 分段锁, 大大提高了高并发环境下的处理能力. 由于不是对整个Map加锁, 所以一些需要扫描整个Map的方法(size())等需要特殊实现, clear甚至放弃了对一致性的要求.
    - 1.8+ 使用CAS算法, 底层使用 数组+链表+红黑树 实现, 同时增加了许多辅助类
        - `sizeCtl`: 负数代表正在进行初始化或者扩容, -1 表示初始化, -N表示N-1个线程正在进行扩容操作, 正数表示还没有被初始化, 下一次扩容的大小, 此值始终是当前哈希表的0.75倍, 即与`loacfactor`对应

## Java 反射
1. 在运行状态中, 对于任意一个类, 都能够知道这个类的所有属性和方法. 对于任意一个对象, 都能够调用他的任意一个方法. 这种动态的回去信息和动态调用对象方法的功能成为Java语言的反射机制
2. 功能:
    - 在运行时判断一个对象所属的类
    - 在运行时构造任意一个类的对象
    - 在运行时判断一个类所有的成员变量和方法
    - 在运行时调用任意一个对象的方法
    - 生成动态代理

## 代理
1. Java动态代理
    - 进行方法的增强, 在不修改源码的情况下, 增强一些方法, 再方法执行前后做一些事情, 甚至不执行方法.
    - JDK动态代理
        - 被代理类必须实现接口
        - 代理类实现`InvocationHandler`接口
        - 调用`Proxy.newProxyInstance`方法获取代理对象
2. 代理模式: 为其他对象提供一种代理以控制对这个对象的访问
3. 正向代理: 正向代理代理的对象是客户端, 是为客户端服务的
4. 反向代理: 反向代理代理的对象是服务器, 是为服务器服务的

## Java NIO
1. 同步非阻塞IO模型, 核心是通道和缓冲区
2. 缓冲(Buffer): 当数据到达时, 预先被写入缓冲区, 再由缓冲区交给线程, 线程无需阻塞的等待IO
    - position: 下一次操作的开始位置
    - capacity: 缓冲区的长度
    - limit: 缓冲区不可操作的下一个元素位置 limit<=capacity
    - mark: 记录当前position的前一个位置
    - clear() : 清空缓冲区 position=0, limit=capacity=buffer.length
    - flip(): 反转缓冲区 limit=position, position=0
    - rewind(): 重绕缓冲区 position=0
3. 通道(Channel): 通道是IO传输发生时通过的路口, 缓冲区是数据的来源或者目标. 数据需要通过通道进入缓冲区, 缓冲区中的数据需要通过通道被线程读取
    - FileChannel : 文件通道, 对应文件IO
    - DatagramChanneal : 数据报套接字通道, 对应UDP
    - SocketChannel: TCP通道
    - ServerSocketChannel: 服务器TCP通道
4. 选择器(Selector): 监听通道事件
    - OP_ACCEPT : 接收就绪
    - OP_CONNECT: 连接就绪
    - OP_READ: 读就绪
    - OP_WRITE: 写就绪

## Java线程池
1. 优点:
    - 降低资源消耗  降低由于线程创建关闭的资源消耗
    - 提高响应速度  消除了线程创建的时间
    - 提高线程的可管理性 线程是稀缺资源, 合理的管理线程会提高系统的稳定性
2. 状态
    - RUNNING: 初始化之后进入此状态
    - SHUTDOWN: 调用shutdown() 方法后进入此状态, 线程池不接受新任务, 等待任务线程执行完毕
    - STOP: 调用shutdownNOW()方法后进入此状态, 线程池不接受新任务, 并尝试中断正在执行的任务
    - TERMINATED: 当所有的工作线程已经销毁, 任务缓存队列清空或执行结束, 进入此状态
3. 使用`Executors`创建线程池
    - newCachedThreadPool: 可缓存的线程池, 可以灵活回收空闲线程, 若无可回收, 创建新线程
    - newFixedThreadPool: 具有固定大小的线程池, `ThreadPoolExecutor`
    - newScheduledThreadPool: 定长线程池, 支持周期性或者定时的任务
    - newSingleThreadPool: 单线程化的线程池, 只用唯一的工作线程执行任务, 按指定顺序执行任务
4. `ThreadPoolExecutor`线程池
    - corePoolSize: 核心池大小
    - BlockingQueue: 任务队列
        - ArrayBlockingQueue: 基于数组的有界阻塞队列
        - LinkedBlockingQueue: 基于链表的阻塞队列, 吞吐量高于`ArrayBlockingQueue`
        - SynchronousQueue: 不存储元素的阻塞队列, 插入操作必须等待另一个线程调用移除操作, 否则阻塞插入, 吞吐量高于`LinkedBlockingQueue`
        - PriorityBlockingQueue: 具有优先级的无限阻塞队列
    - maximumPoolSize: 线程池最大容量
    - ThreadFactory: 创建线程的工厂
    - RejectedExecutionHandler: 饱和策略, 当队列和线程池都满, 处理提交任务的策略
        - AbortPolicy: 抛出异常, 默认
        - CallerRunsPolicy: 使用调用`execute`方法的线程运行任务, 若执行程序关闭, 则丢弃该任务
        - DiscardOldestPolicy: 放弃最旧的未处理请求, 重试`execute`
        - DiscardPolicy: 丢弃任务
5. 提交任务:
    - execute(): 提交无返回值的任务
    - submit(): 提交返回`future`的任务
6. 关闭:
    - shutdown(): 将线程池的状态设为`SHUTDOWN`, 中断没有正在执行任务的线程
    - shutdownNow(): 将线程池的状态设为`STOP`, 遍历工作线程, 调用`interrupt`方法中断线程
7. 动态调整容量
    - setCorePoolSize: 设置核心池大小
    - setMaximumPoolSize: 设置线程池最大容量

## MySQL
1. 锁:
    - Mysql的锁主要有行锁/表锁/页锁/悲观锁, 不同的引擎支持的锁特性如下:

    ||行锁|表锁|页锁|
    | :-- | :--: | :--: | :--: |
    |MyISAM||√||
    |BDB||√|√|
    |InnoDB|√|√||
    - 表锁: 开销小, 加锁快, 不会出现死锁; 锁定力度大, 发生冲突概率高, 并发度最低
    - 行锁: 开销大, 加锁慢, 会出现死锁; 锁定力度小, 发生锁冲突的概率低, 并发度高
    - 页锁: 开销和加锁速度介于表锁和行锁之间; 会出现死锁, 锁定力度介于表锁和行锁之间
    - 共享锁: 又称读锁, 多个事务可以共享一把锁, 都能访问到数据, 只读
    - 排他锁: 又称写锁, 只有一个事务可以获得一个数据行的排他锁, 其他事务不能获取该行的其他所, 包括读锁和写锁.
2. 笛卡儿积: 多表查询时记录之间组合
3. 索引:
    - 索引是帮助MySQL高效获取数据的数据结构
    - 优势: 1. 提高数据检索效率,减少数据库的IO成本  2. 通过索引对数据进行排序, 降低数据排序的成本, 降低了CPU的消耗
    - 劣势: 索引也是一张表, 保存了主键与索引字段, 并指向实体表的记录, 所以索引也需要占用额外的空间. 同时, 虽然大大提高了查询的速度, 但是降低了更新表的速度, 因为更新表时, MySQL不仅需要保存数据, 还需要保存索引文件
    - 常见索引:
        - 普通索引(INDEX)
        - 唯一索引(UNIQUE): 索引列的值必须唯一, 但允许有空值
        - 主键索引(PRIMARY): 特殊的唯一索引, 不允许有空值
        - 全文索引(FULLTEXT): 仅可用于MyISAM表, 针对较大的数据,生成全文索引费时间
        - 组合索引 可以更多的提高检索的效率, 遵循"最左前缀"原则
    - 最左前缀原则: 组合索引扫描时首先选择左边的列, 所以创建组合索引时将使用最频繁的放在最左边
    - MySQL索引结构
         - B+Tree索引(InnoDB, MySIAM)
         - Hash索引
    - 聚簇索引:
        - MyISAM非聚簇索引, 主索引和辅助索引没有本质区别, 叶子节点存储数据存放的地址.
        - InnoDB聚簇索引, 数据文件本身就是索引文件, 叶子节点的data就是数据本身. 所以检索的时候若是主键则直接索引, 非主键先检索主键, 然后检索整条纪录. 聚簇索引是顺序结构与数据存储物理结构一致的一种索引, 一个表的聚簇索引只能有唯一的一条.
4. 范式:
    - 范式可以理解一张数据表的表结构所符合的某种设计标准的级别
    - 第一范式`1NF`: 符合第一范式的关系中的属性都不可再分. 有四个问题:
        - 数据冗余过大
        - 插入异常
        - 删除异常
        - 修改异常
    - 第二范式`2NF`:在第一范式的基础上, 消除了非主属性对码的部分函数依赖
        - 函数依赖: 在一张表中, 若在属性(组)A确定的情况下必定能确定属性B的值, 则称B函数依赖于A, 记作`A -> B`
            - 完全函数依赖: 属性组A可以确定B, 属性组A的真子集不能确定, 则称B对于A完全函数依赖
            - 部分函数依赖: 属性组A的部分属性即可确定B, 称B部分函数依赖于A
            - 传递函数依赖: 若C函数依赖于B, B函数依赖于A, B不包含于A且A不函数依赖于B, 则称C传递依赖于A
        - 码: 设K为表中的一个属性或者属性组, 若除K外的所有属性**完全**函数依赖于K, 则称K为候选码, 简称为码. 一张表中可以有多个码, 通常选一个作为主码
        - 主属性: 包含在任意一个码中的属性称为主属性
        - 模式分解: 将大数据表拆分成多个小数据表, 使之符合更高一级范式的要求, 这个过程叫模式分解
    - 第三范式`3NF`: 在第二范式的基础上, 消除非主属性对码的传递函数依赖
        - 符合3NF设计的数据库设计, **基本**消除了数据冗余过大, 插入异常, 删除异常, 修改异常的问题 .
    - 巴斯范式`BCNF`: 在第三范式的基础上, 消除主属性对码的部分或者传递函数依赖
5. 事务:
    - READ_UNCOMMIT: 读取未提交数据, 最低层次
    - READ_COMMIT: 读取提交数据, 避免脏读, 可能导致不可重复读和幻读
    - REPEATABLE READ: 可重复读
    - SERIALIZABLE: 序列化, 避免所有问题, 但是可能导致性能下降
6. 引擎:
    - InnoDB: 支持事务, 支持外键, 聚集索引, 不保存行数, 不支持全文索引. 数据文件本身就是索引文件, 节点的Data域保存了完整的数据记录, 索引的key是数据表的主键.
    - MyISAM: 不支持事务, 不支持外键, 非聚集索引, 保存行数, 支持全文索引, 索引文件和数据文件分离, 索引文件仅仅保存数据记录的地址.
    - InnoDB引擎会监控对标上索引的查找, 若观察到建立哈希索引会带来速度的提升, 则建立哈希索引, 是自适应的.
    - Heap引擎默认的就是哈希索引
7. SQL:
    - 排序: `order by column (desc)`
    - 返回的记录条数: `limit (begin,)num`
    - LIKE 通配符 `%: 零或多个字符; _: 一个字符;`
    - (NOT) REGEXP 正则表达式: `[charlist]: 列表中任意一个字符; [^charlist]: 非列表中的任意字符; [a-z]: a-z 任意字符`
    - IN WHERE多个值: `where value in (v1, v2, v3)`
    - BETWEEN AND 范围取值: `where value between v1 and v2`
    - 连接查询JOIN:
        - 连接查询是建立在笛卡儿积的基础上的
        - 内连接(INNER　JOIN), 在笛卡儿积中挑选出符合条件的记录: `select * from t1 inner join t2 on t1.id=t2.id`
        - 左连接(LEFT JOIN), 在笛卡儿积中挑选出符合条件的记录外加左表剩余的记录: `select * from t1 left join t2 on t1.id=t2.id`
        - 右连接(RIGHT JOIN), 在笛卡儿积中挑选出符合条件的记录外加右表剩余的记录: `select * from t1 right join t2 on t1.id=t2.id`
        - 外连接(OUTER JOIN), 可以理解为左连接+右连接: `select * from t1 left join t2 on t1.id=t2.id union select * from t1 right join t2 on t1.id = t2.id`
        - 当作为条件的两列同名时可以用`using(colum)`简化条件, 作为条件的列只会出现一次
    - group by 分组: `select count(*), type from v1 group by type`
    - Having: 在`group by`语句之后筛选数据

## 设计模式
1. 工厂模式 : 单独的工厂类来负责创建实例, 把对象的创建和使用的过程分开, 解除耦合.
2. 抽象工厂模式 : 超级工厂负责建立其他工厂, 其他的工厂负责创建具体的实例
3. 建造者模式
4. 原型模式
5. 单例模式 一个类只有一个实例, 并提供一个全局的访问点
6. 适配器模式 使原来由于接口不兼容而不能一起工作的类可以一起工作
7. 桥接模式
8. 组合模式
9. 装饰模式
10. 外观模式
11. 享元模式
12. 代理模式
13. 解释器模式
14. 模板方法
15. 责任链模式
16. 命令模式
17. 迭代器模式
18. 中介者模式
19. 备忘录模式
20. 观察者模式
21. 状态模式
22. 策略模式 对一系列的算法定义, 将每一个算法封装起来, 而且使他们可以相互替换. 策略模式让算法独立于使用他的客户而独立变化
23. 访问者模式

## 计算机网络
1. 分层体系结构:
    - OSI七层:  应用层 <- 表示层 <- 会话层 <- 运输层 <- 网络层 <- 数据链路层 <- 物理层
    - TCP/IP四层: 应用层 <- 运输层 <- 网际层 <- 数据链路层
    - 五层: 应用层 <- 运输层 <- 网络层 <- 数据链路层 <- 物理层
    - 优点:
        - 各层独立, 只通过层间接口交互
        - 灵活, 只要交互接口不变就不会导致层变化
        - 各层采用最合适的技术不必考虑其他层
        - 有利于促进标准化
2. 三次握手:
    - 客户端 -> (SYN=1, seq=x) -> 服务器
    - 客户端 <- (SYN=1, seq = y, ack=x+1) <- 服务器
    - 客户端 -> (ACK=1, seq = x+1, ack = y+1) -> 服务器
3. 四次挥手:
    - 客户端 -> (FIN M ) -> 服务器
    - 客户端 <- (ack M+1) <- 服务器
    - 客户端 <- (FIN N) <-服务器
    - 客户端 -> (ACK=1, ack=K+1) -> 服务器
4. Http:
    - 长短连接: Http1.0默认短连接, 每进行一次Http操作就建立一次连接. Http1.1默认长连接, 加入响应头`Connection: keep-alive`, 设置保持的有效时间
    - Http的长短连接实质上是TCP的长短连接. TCP短连接每次Client和Server交互一次就关闭, 长连接由一个保持时间, 并且由服务器提供保活功能.
    - 长短连接优缺点
        - 长连接可以省去较多的TCP建立和关闭的操作, 减少浪费, 节约时间. 不过当客户端太多的时候, 服务器如果不加以限制会导致过多的连接拖垮服务器
        - 短连接较为简单, 但是如果客户端由较为频繁的请求操作会浪费很多时间在连接的建立和释放上
5. Https:
    - Http缺点: 不安全, 明文传输
    - 组成: Http + SSL/TLS
    - 过程:
        - 客户端发送支持的加密协议及版本
        - 服务器筛选合适的加密协议
        - 服务器返回含有公钥的证书
        - 客户端使用根证书验证证书的合法性
        - 客户端生成对称密钥, 通过公钥加密, 发送给服务器
        - 服务器使用私钥解密, 获取对称密钥, 使用对称密钥加密数据
        - 客户端解密数据, SSL开始通信..
6. TCP报文格式:
    - 源端口号(2B), 目的端口号(2B)
    - 序号(4B)
    - 确认序号(4B)
    - 首部长度(4b, 单位为4B) 保留(4b) 标识位(6b) 窗口大小(2B, 最大可以表示65535)
    - 检验和(2B) 紧急指针(2B)
    - 任选字段(0-40B)
    - 数据部分
7. TCP粘包
    - 形成原因: TCP是基于字节流和缓存进行传输的, 建立连接之后可以一直发送数据, 并没有明确的边界定义, 所以接收端在一次接收中可能并不会接收到所需的所有数据, 后续发送的数据可能和缓冲区中的数据一同发送, 这就产生了粘包的问题
    - 解决办法
        - 采用**数据长度+实际数据**的方式发送, 接收端首先接收数据长度, 然后在接收到对应的数据时再去处理
        - 固定长度: 协商每次数据的长度, 接收端每次接收对应长度的数据
        - 重新连接: 在一次数据发送完成之后关闭连接, 下次在重新建立连接. 这种方法对频繁的小数据传输是不可取的, 连接的建立和释放会消耗大量的时间
8. DDoS攻击:
    - 概念: 分布式拒绝服务攻击. 攻击者利用`肉鸡`对目标发动大量正常或者异常的请求, 导致被攻击的目标无法为正常的合法用户提供服务
    - 方式:
        - SYN Flood: 利用TCP建立连接的三次握手, 当客户端向服务器发送建立连接的`SYN`请求后, 服务器应该返回`SYN+ACK`, 若此时客户端掉线, 服务器就会重发并且等待一段时间后丢弃, 此时称为`半连接`, 当服务器维护一个巨大的半连接列表时, 会消耗掉巨大的资源.
        - NTP 反射攻击: NTP协议是标准的网络时间同步协议, 攻击者伪造目标服务器向NTP服务器发送时钟同步请求报文, NTP服务器就会向目标服务器发送最近与其时间同步的服务器IP, 占用目标服务器巨大的网络资源.
        - DNS: 伪造DNS请求, 攻击DNS服务器.
9. NAT 网络地址转换:
    - 利用少量的公网IP即可使内网的多个计算机与公网通信
    - 功能: 带宽分享 , 安全防护
    - 实现方式:
        - 静态转换: 内网的IP地址转为公网的IP地址是一成不变的.
        - 动态转换: 内网的IP地址随机转换为公网的IP地址
        - 端口多路复用: 改变外出数据包的源端口并进行端口转换. 采用这种方式, 内部网络的所有主机均可以共享一个合法的外部IP地址实现对Internet的访问, 从而最大限度的节约IP地址资源. 同时, 又可以隐藏网络内部的所有主机, 有效避免来自Internet的攻击. 应用最多的方式
        - ALG(应用程序级网关技术): 传统的NAT技术只对IP层和传输层的头部进行处理, 但是一些应用层协议在协议数据报文中包含了地址信息, ALG技术可以对数据报文中的地址信息也进行相应的NAT转换

## 算法
1. 时间复杂度: 一个定量描述算法运行时间的函数

## 数据结构
1. 二叉查找树
    - 性质:
        - 若左子树不为空, 则左子树节点的值均小于等于它根节点的值
        - 若右子树不为空, 则右子树节点的值均大于等于它根节点的值
        - 左右子树也分别为二叉查找树
    - 插入:
        - 先查找
        - 把节点作为叶子节点插入
    - 删除:
        - 先查找
        - 分情况:
            - 节点为叶节点: 直接删除
            - 节点只有左子树或者右子树: 把左子树或者右子树替换当前节点
            - 节点有左右子树: 找出此节点右子树的最小节点, 用以代替要删除的节点, 删除此最小节点
2. 平衡二叉树(AVL)
    - 性质:
        - 左子树和右子树的深度之差的绝对值不超过1
        - 左右子树都是平衡二叉树
    - 特性:
        - 非叶子节点最多拥有两个子节点
        - 非叶子节点值大于左边小于右边
        - 没有值相等重复的节点
3. B树(B-Tree) 平衡多路查找树, 多叉
    - 性质:(m 树的查找路径数)
        - 节点最多拥有m个子节点且m>=2
        - 除根节点外每个节点的关键字数量大于等于`(m/2)-1`个,小于等于`m-1`个, 非根节点关键字数大于等于2
        - 所有的叶子节点都在同一层
        - 若非叶节点有N个子节点, 则该节点的关键字数等于N-1
        - 所有的节点关键字按递增次序排列, 遵循左小右大的原则
    - 特性:
        - 相比平衡二叉树每个节点包含的关键字增多了, 降低了树的高度, 减少数据查找的次数和复杂度
4. B+树:
    - 性质:
        - B-树的升级版
        - 非叶子节点的子树指针和关键字个数相同
        - 非叶子节点的子树指针, 指向关键字属于[K[i], K[i+1])的子树
        - 所有叶子节点具有链指针
        - 所有的关键字都在叶子节点出现
    - 特性:
        - 相比B-树每个节点存储的关键字更多, 属的层级更少, 查询速度更快
        - 所有的关键字都在叶子节点的链表中, 并且是有序的, 每次查找的速度相同, 查询速度稳定
        - 不可能在非叶子节点命中
        - 非叶子节点相当于是叶子节点的索引, 叶子节点相当于存储数据的数据层
        - 适合文件索引系统
5. B*树
    - 性质:
        - B+树的变种
        - 在B+树的基础上增加节点指向其兄弟节点的指针
        - B*树非叶子节点关键字个数至少为`(2/3)*m`, 即块的最低使用率为`2/3`, B+树为`1/2`
        - B*树节点满时首先检查兄弟节点是否已满, 若未满, 则将数据转移到兄弟节点, 若满则在源节点和兄弟节点之间增加新节点, 并且复制各`1/3`数据到新节点, 在父节点增加指向新节点的指针
        - B*树分配新节点的概率比B+树低, 空间使用率高
6. 红黑树 : 在对数时间内完成查找
    - 性质:
        - 每个节点为红色或者黑色
        - 根节点为黑色
        - 空节点为黑色
        - 红色节点的两个子节点为黑色
        - 从任意节点到其每个叶节点的所有路径都包含相同数目的黑色节点
    - 变换:
        - 左旋: A节点的左旋即为把A右节点的左孩子变成A的右孩子, 把A变为右节点的左孩子, 最后把原A的位置替换为A的右孩子
        - 右旋: 左旋的逆过程
    - 操作:
        - 插入: 把节点涂成红色, 然后插入, 最后通过一系列变换使树符合红黑树定义
        - 删除: 先变换, 然后删除
    - 特性:
        - 不是完美的平衡二叉树
        - 动态插入删除的代价比完美的平衡二叉树低
        - 可以在对数时间内完成查找

## 操作系统
1. select&epoll: IO多路复用技术
    - select : 只提示有IO请求, 程序需要遍历列表
    - epoll: 活跃的socket才回调, 效率高

## 进程与线程
1. 进程: 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动, 进程是系统进行资源分配和调度的一个独立单位
2. 线程: 线程是进程的一个实体, 是CPU调度和分派的基本单位, 是比进程更小的能独立运行的基本单位. 线程自己基本上不拥有系统资源
3. 线程安全:**当多线程访问同一个对象时, 如果不用考虑这些线程在运行时环境下的调度和交替执行, 也不需要进行额外的同步, 或者在调用方进行任何其他的协调操作, 调用这个对象的行为都可以获得正确的结果, 那这个对象是的**
4. Java线程的五种状态
    - 新建(New): 创建后尚未启动的线程处于此种状态
    - 运行(Runable) : Runable包含了操作系统线程状态中的Running和Ready, 即处于此种状态的线程可能正在执行, 也可能等待CPU为他分配执行时间
    - 无限期等待(Waiting): 处于此种状态的线程不会被分配执行时间, 他们要等待被其他线程显式地唤醒
        - 没有设置Timeout参数的Object.wait()
        - 没有设置Timeout参数的Thread.join()
        - LockSupport.park()
    - 限期等待(Timed Waiting): 处于此种状态的线程也不会被分配执行时间, 不过他们无需等待被其他线程唤醒, 以下方法会让线程进入限期等待状态:
        - Thread.sleep()
        - 设置了Timeout参数的Object.wait()方法
        - 设置了Timeout参数的Thread.join()方法
        - LockSupport.parkNanos()方法
        - LockSupport.parkUntil()方法
    - 阻塞(Blocked): 线程被阻塞了, "阻塞状态"与"等待状态"的区别是: "阻塞状态" 在等待着获取一个排他锁, 此事件将在另一个线程放弃这个锁的时候发生; "等待状态"则是在等待一段时间, 或者唤醒动作的发生. 在程序等待进入同步区域的时候, 线程将进入此种状态
    - 结束(Terminated): 已终止线程的线程状态, 线程已经结束执行
5. 线程通信:
    - 同步, `synchronized`
    - `while`轮询
    - `wait/notify`机制
    - 管道通信
6. 进程通信:
    - 管道及有名管道
    - 信号量
    - 消息队列
    - 共享内存 最快的方式
    - 套接字
7. Java 线程通信常用类:
    - `CountDownLatch`: 计数器, 等待计数为0时执行后续代码
    - `CyclicBarrier`: 可以让一组线程等到某个状态继续执行后续代码
    - `Semaphore` 信号量: 通过获取和释放许可控制同时访问的线程个数
8. Java 锁:
    - 是否公平调度(`ReentrantLock(boolean)`):
        - 公平锁: 多线程在等待同一个锁时, 必须按照申请的先后顺序来一次获得锁. 优点是等待的线程不会饿死, 缺点是效率较低
        - 非公平锁: 抢占式. 整体效率较高, 但是可能导致线程等待时间过长
    - 显式锁和隐式锁 Lock & synchronized
        - 隐式锁`synchronized`: 自动加锁释放锁
        - 显式锁`Lock`: 提供了无条件的/可轮询的/定时的/可中断的锁获取操作, 所有的加锁和释放锁的操作都是显式的, 比隐式锁更灵活
    - 是否可重入:
        - 可重入锁(递归锁): 又称为递归锁, 指的是同一线程外层函数获得锁之后, 内层递归函数仍然可以获取该锁. 包括`ReentrantLock&synchronized`, 可以避免死锁.
        - 不可重入锁(自旋锁): 只有当前线程获取唯一锁的时候才可以进入同步代码块
    - 存在于对象头中的锁:
        - 轻量级锁: 通过CAS操作将对象锁定, 通过CAS操作释放
        - 重量级锁: 当有两个及以上的线程争用同一个锁时, 轻量级锁不在有效, 要膨胀为重量级锁
        - 偏向锁: 在无竞争的情况下把整个同步都消除掉, 不做CAS操作. 偏向锁的"偏"就是偏向于第一个获得他的线程, 在接下来的执行过程中, 若没有被其他线程获取, 则持有偏向锁的线程将永远不需要同步
9. ThreadLocal:
    - 提供线程内部的局部变量, 变量在线程的声明周期内起作用, 减少同一个线程内多个函数或者组件之间一些公共变量的传递复杂度

## Hibernate
1. 缓存:
     - 一级缓存(Session), 属于事务范围的缓存, 应用程序无需干预
     - 二级缓存(Session Factory), 该缓存可以进行配置管理, 可以动态加载和卸载. Hibernate提供了查询缓存, 依赖于二级缓存.

## JVM
1. 内存分区:
    - 程序计数器 线程私有, 可以看作行号指示器
    - 虚拟机栈 线程私有, 方法执行的内存模型, 内有栈帧, 存储局部变量/操作数栈/动态链接等信息. 方法调用的过程对应栈帧在虚拟机栈中的入栈和出栈
    - 本地方法栈 native方法执行的内存模型, 许多虚拟机合并了本地方法栈和虚拟机栈
    - 堆 存放对象实例, 对象在此地被分配内存, 是垃圾收集器管理的主要区域, 分为新生代(Eden, From Survivor, To Survivor)和老年代
    - 方法区 线程共享, 存储已经被虚拟机加载的类信息, 常量, 静态变量, 即时编译后的代码等数据, 又称为永久代
    - 方法区中的 运行时常量池 存放编译器生成的各种字面量和符号引用, 具有动态性, 可以在运行时加入新的常量
2. 垃圾算法:
    - 标记-清除: 简单; 效率低, 产生大量内存碎片, 提前触发下一次垃圾收集
    - 复制算法: 简单高效, 无内存碎片问题; 内存利用率低   - 当前主流的收集算法, 分区
    - 标记-整理: 先标记, 然后移动对象, 最后清除掉边界以外的内存
    - 分代收集算法: 把Java堆分为新生代和老年代, 根据不同的特点使用不同的算法
        - 新生代每次收集只有少量对象存活, 适合复制算法
        - 老年代对象存活率低, 没有担保,  使用标记-清除或者标记-整理
3. 对象死亡判定方法:
    - 引用计数: 简单, 但是无法解决对象之间循环引用问题
    - 可达性分析: 通过一系列的`GC Roots`对象作为起始点, 向下搜索, 形成引用链, 当一个对象没有任意一个引用链与之相连则说明此对象不可达, 可作为`GC Root`的对象有:
        - 虚拟机栈中的对象
        - 方法区中类静态属性引用的对象
        - 方法区中常量引用的对象
        - 本地方法栈中native方法引用的对象
4. 垃圾收集器:
    - Serial 收集器: 单线程, 进行收集时停顿所有线程(Stop the World), Client模式下新生代默认的收集器, 简单高效
    - ParNew 收集器: Serial收集器的多线程版本, Server模式下新生代默认的收集器, 唯一可以与CMS收集器搭配使用
    - Parallel Scavenge:  采用复制算法的新生代收集器, 此收集器关注的是达到一个可控制的吞吐量
    - Serial Old: Serial收集器的老年代版本, 单线程, 基于标记整理算法
    - Parallel Old: Parallel 收集器的老年代版本, 多线程, 采取标记整理算法, 在注重吞吐量以及CPU效率的场合使用
    - CMS(Concurrent Mark Sweep) 收集器:
        - 以最短的停顿时间为目标
        - 采用标记清除算法
        - 标记过程: 初始标记(Stop the world) -> 并发标记 ->重新标记(Stop the world) -> 并发清除
        - 缺点: 对CPU资源非常敏感, 会导致系统吞吐量[(执行用户代码的时间)/(执行用户代码的时间+垃圾收集时间)]降低; 无法处理浮动垃圾; 标记清除算法产生大量的内存碎片
    - G1收集器: 当代收集器发展最前沿的成果之一, 面向的是服务端应用
        - 优点: 并行与并发(充分利用多CPU, 多核环境的硬件优势), 分代收集, 空间整合, 可预测的停顿
        - 运行步骤: 初始标记 -> 并发标记 -> 最终标记 -> 筛选回收
## Redis
1. Redis 是开源的内存中的数据结构存储, 用作数据库,缓存和消息中间件
2. 优势:
    - 速度快. 数据在内存中存储, 类似HashMap, 操作的时间复杂度为O(1)
    - 支持的类型丰富. 支持字符串(String),列表(List), 集合(Set), 哈希(Hash)
    - 支持事务, 操作为原子性.
    - 可用于缓存, 消息, 可以设置数据过期时间
3. 与`memcached`对比
    - `memcached`只支持字符串, `redis`支持更丰富的数据类型
    - `redis`速度快于`memcached`
    - `redis`可以持久化数据
## Linux
1. 常用命令:
    - grep: 过滤
    - uname: 系统信息
    - ifconfig: 网卡配置
    - netstat: 网络状态信息
    - route: 查看路由表
    - pwd: 工作路径
    - mkdir: 新建目录
    - touch: 新建文件
    - cp: 复制文件
    - cat/head/tail: 显示文件内容
    - mv: 移动文件
    - rm: 删除文件
    - ln: 新建链接
    - find: 查找
    - chgrp/chmod/chown: 修改组/所有/所有人权限
    - gzip/tar/zip: 压缩文件
    - dnf: 管理软件包
    - make/cmake: 编译文件
    - echo: 回显内容
    - whereis: 查找文件
## Others
1. 跨站脚本攻击(XSS): 未完全过滤客户提交的数据.
    - 存储型: 将恶意代码上传至服务器, 服务器未经过滤就渲染在HTML代码中, 用户访问网页时自动执行恶意脚本
    - 反射型: 服务器中没有恶意代码, 诱导用点击连接触发的XSS代码
2. 一致性哈希算法: 避免当服务器数量改变时缓存大规模失效. 利用哈希环和虚拟节点, 当动态改变服务器数量时缓存只有小部分失效
3. 微服务
4. jvm
5. 事务/aop/ioc/测试
6. JIT
7. transient 不需要序列化
8. 嵌套`synchronized`死锁
9. volatile
10. 词法分析 -> 语法分析 -> 语义分析与中间代码生成 -> 优化 -> 目标代码生成
11. SpringMVC&Struts2:
    - Struts2 通过Filter实现请求转发, SpringMVC通过servlet实现请求转发
    - Struts2 是基于类的, SpringMVC是基于方法开发
    - Struts2是一个请求一个Action, SpringMVC是单例模式
    - SpringMVC开发效率高于Struts2