### Java Map
1. HashMap 在1.7- 是数组加链表实现, 1.8 是数组+链表+红黑树 , 当链表长度大于8时转为红黑树
2. HashTable 锁住整个表, SynchronizedMap 同步代码块
3. ConcurrentHashMap 
    - 1.7- 分段锁, 大大提高了高并发环境下的处理能力. 由于不是对整个Map加锁, 所以一些需要扫描整个Map的方法(size())等需要特殊实现, clear甚至放弃了对一致性的要求. 
    - 1.8+ 使用CAS算法, 底层使用 数组+链表+红黑树 实现, 同时增加了许多辅助类
        - `sizeCtl`: 负数代表正在进行初始化或者扩容, -1 表示初始化, -N表示N-1个线程正在进行扩容操作, 正数表示还没有被初始化, 下一次扩容的大小, 此值始终是当前哈希表的0.75倍, 即与`loacfactor`对应
### MySQL
1. 锁:
    - Mysql的锁主要有行锁/表锁/页锁/乐观锁/悲观锁, 不同的引擎支持的锁特性如下:

    ||行锁|表锁|页锁|
    | :-- | :--: | :--: | :--: |
    |MyISAM||√||
    |BDB||√|√|
    |InnoDB|√|√||
    - 表锁: 开销小, 加锁快, 不会出现死锁; 锁定力度大, 发生冲突概率高, 并发度最低
    - 行锁: 开销大, 加锁慢, 会出现死锁; 锁定力度小, 发生锁冲突的概率低, 并发度高
    - 页锁: 开销和加锁速度介于表锁和行锁之间; 会出现死锁, 锁定力度介于表锁和行锁之间
2. 笛卡儿积: 多表查询时记录之间组合
3. 索引: 
    - 索引是帮助MySQL高效获取数据的数据结构
    - 优势: 1. 提高数据检索效率,减少数据库的IO成本  2. 通过索引对数据进行排序, 降低数据排序的成本, 降低了CPU的消耗
    - 劣势: 索引也是一张表, 保存了主键与索引字段, 并指向实体表的记录, 所以索引也需要占用额外的空间. 同时, 虽然大大提高了查询的速度, 但是降低了更新表的速度, 因为更新表时, MySQL不仅需要保存数据, 还需要保存索引文件
    - 常见索引: 
        - 普通索引(INDEX)
        - 唯一索引(UNIQUE): 索引列的值必须唯一, 但允许有空值
        - 主键索引(PRIMARY): 特殊的唯一索引, 不允许有空值
        - 全文索引(FULLTEXT):
        - 组合索引
    - MySQL索引结构
         - B+Tree索引(InnoDB, MySIAM)
         - Hash索引
    - 聚簇索引: 
        - MyISAM非聚簇索引, 主索引和辅助索引没有本质区别, 叶子节点存储数据存放的地址.
        - InnoDB聚簇索引, 数据文件本身就是索引文件, 叶子节点的data就是数据本身. 所以检索的时候若是主键则直接索引, 非主键先检索主键, 然后检索整条纪录
4. 范式:
    - 范式可以理解一张数据表的表结构所符合的某种设计标准的级别
    - 第一范式`1NF`: 符合第一范式的关系中的属性都不可再分. 有四个问题:
        - 数据冗余过大
        - 插入异常
        - 删除异常
        - 修改异常
    - 第二范式`2NF`:在第一范式的基础上, 消除了非主属性对码的部分函数依赖
        - 函数依赖: 在一张表中, 若在属性(组)A确定的情况下必定能确定属性B的值, 则称B函数依赖于A, 记作`A -> B`
            - 完全函数依赖: 属性组A可以确定B, 属性组A的真子集不能确定, 则称B对于A完全函数依赖
            - 部分函数依赖: 属性组A的部分属性即可确定B, 称B部分函数依赖于A
            - 传递函数依赖: 若C函数依赖于B, B函数依赖于A, B不包含于A且A不函数依赖于B, 则称C传递依赖于A
        - 码: 设K为表中的一个属性或者属性组, 若除K外的所有属性**完全**函数依赖于K, 则称K为候选码, 简称为码. 一张表中可以有多个码, 通常选一个作为主码
        - 主属性: 包含在任意一个码中的属性称为主属性
        - 模式分解: 将大数据表拆分成多个小数据表, 使之符合更高一级范式的要求, 这个过程叫模式分解
    - 第三范式`3NF`: 在第二范式的基础上, 消除非主属性对码的传递函数依赖
        - 符合3NF设计的数据库设计, **基本**消除了数据冗余过大, 插入异常, 删除异常, 修改异常的问题 .
    - 巴斯范式`BCNF`: 在第三范式的基础上, 消除主属性对码的部分或者传递函数依赖
5. 事务:
    - READ_UNCOMMIT: 读取未提交数据, 最低层次
    - READ_COMMIT: 读取提交数据, 避免脏读, 可能导致不可重复读和幻读
    - REPEATABLE READ: 可重复读
    - SERIALIZABLE: 序列化, 避免所有问题, 但是可能导致性能下降
6. 引擎:
    - InnoDB: 支持事务, 支持外键, 聚集索引, 不保存行数, 不支持全文索引
    - MyISAM: 不支持事务, 不支持外键, 非聚集索引, 保存行数, 支持全文索引
7. SQL:
    - 排序: `order by column (desc)`
    - 返回的记录条数: `limit (begin,)num`
    - LIKE 通配符 `%: 零或多个字符; _: 一个字符; `
    - (NOT) REGEXP 正则表达式: `[charlist]: 列表中任意一个字符; [^charlist]: 非列表中的任意字符; [a-z]: a-z 任意字符`
    - IN WHERE多个值: `where value in (v1, v2, v3)`
    - BETWEEN AND 范围取值: `where value between v1 and v2`
    - 连接查询JOIN:
        - 连接查询是建立在笛卡儿积的基础上的
        - 内连接(INNER　JOIN), 在笛卡儿积中挑选出符合条件的记录: `select * from t1 inner join t2 on t1.id=t2.id`
        - 左连接(LEFT JOIN), 在笛卡儿积中挑选出符合条件的记录外加左表剩余的记录: `select * from t1 left join t2 on t1.id=t2.id`
        - 右连接(RIGHT JOIN), 在笛卡儿积中挑选出符合条件的记录外加右表剩余的记录: `select * from t1 right join t2 on t1.id=t2.id`
        - 外连接(OUTER JOIN), 可以理解为左连接+右连接: `select * from t1 left join t2 on t1.id=t2.id union select * from t1 right join t2 on t1.id = t2.id`
        - 当作为条件的两列同名时可以用`using(colum)`简化条件, 作为条件的列只会出现一次
    - group by 分组: `select count(*), type from v1 group by type`
    - Having: 在`group by`语句之后筛选数据
### 设计模式
1. 工厂模式 : 单独的工厂类来负责创建实例
2. 抽象工厂模式 : 产品之间的抽象关系
3. 建造者模式
4. 原型模式
5. 单例模式
6. 适配器模式
7. 桥接模式
8. 组合模式
9. 装饰模式
10. 外观模式
11. 享元模式
12. 代理模式
13. 解释器模式
14. 模板方法
15. 责任链模式
16. 命令模式
17. 迭代器模式
18. 中介者模式
19. 备忘录模式
20. 观察者模式
21. 状态模式
22. 策略模式
23. 访问者模式
### 计算机网络:
1. 分层体系结构:
    - OSI七层:  应用层 <- 表示层 <- 会话层 <- 运输层 <- 网络层 <- 数据链路层 <- 物理层
    - TCP/IP四层: 应用层 <- 运输层 <- 网际层 <- 数据链路层
    - 五层: 应用层 <- 运输层 <- 网络层 <- 数据链路层 <- 物理层
    - 优点:
        - 各层独立, 只通过层间接口交互
        - 灵活, 只要交互接口不变就不会导致层变化
        - 各层采用最合适的技术不必考虑其他层
        - 有利于促进标准化
2. 三次握手:
    - 客户端 -> (SYN=1, seq=x) -> 服务器
    - 客户端 <- (SYN=1, seq = y, ack=x+1) <- 服务器
    - 客户端 -> (ACK=1, seq = x+1, ack = y+1) -> 服务器
3. 四次挥手:
    - 客户端 -> (FIN M ) -> 服务器
    - 客户端 <- (ack M+1) <- 服务器
    - 客户端 <- (FIN N) <-服务器
    - 客户端 -> (ACK=1, ack=K+1) -> 服务器
### 算法:
1. 时间复杂度: 一个定量描述算法运行时间的函数
### 进程与线程:
1. 进程: 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动, 进程是系统进行资源分配和调度的一个独立单位
2. 线程: 线程是进程的一个实体, 是CPU调度和分派的基本单位, 是比进程更小的能独立运行的基本单位. 线程自己基本上不拥有系统资源
3. 线程通信:
    - 同步, `synchronized`
    - `while`轮询
    - `wait/notify`机制
    - 管道通信
4. 进程通信:
    - 管道及有名管道
    - 信号量
    - 消息队列
    - 共享内存
    - 套接字
5. Java 线程通信常用类:
    - `CountDownLatch`: 计数器, 等待计数为0时执行后续代码
    - `CyclicBarrier`: 可以让一组线程等到某个状态继续执行后续代码
    - `Semaphore` 信号量: 通过获取和释放许可控制同时访问的线程个数
### Hibernate
1. 缓存:
     - 一级缓存(Session), 属于事务范围的缓存, 应用程序无需干预
     - 二级缓存(Session Factory), 该缓存可以进行配置管理, 可以动态加载和卸载. Hibernate提供了查询缓存, 依赖于二级缓存.
### JVM
1. 内存分区:
    - 程序计数器 线程私有, 可以看作行号指示器
    - 虚拟机栈 线程私有, 方法执行的内存模型, 内有栈帧, 存储局部变量/操作数栈/动态链接等信息. 方法调用的过程对应栈帧在虚拟机栈中的入栈和出栈
    - 本地方法栈 native方法执行的内存模型, 许多虚拟机合并了本地方法栈和虚拟机栈
    - 堆 存放对象实例, 对象在此地被分配内存, 是垃圾收集器管理的主要区域, 分为新生代(Eden, From Survivor, To Survivor)和老年代
    - 方法区 线程共享, 存储已经被虚拟机加载的类信息, 常量, 静态变量, 即时编译后的代码等数据, 又称为永久代
    - 方法区中的 运行时常量池 存放编译器生成的各种字面量和符号引用, 具有动态性, 可以在运行时加入新的常量
2. 垃圾算法:
    - 标记-清除: 简单; 效率低, 产生大量内存碎片, 提前触发下一次垃圾收集
    - 复制算法: 简单高效, 无内存碎片问题; 内存利用率低   - 当前主流的收集算法, 分区
    - 标记-整理: 先标记, 然后移动对象, 最后清除掉边界以外的内存
    - 分代收集算法: 把Java堆分为新生代和老年代, 根据不同的特点使用不同的算法
        - 新生代每次收集只有少量对象存活, 适合复制算法
        - 老年代对象存活率低, 没有担保,  使用标记-清除或者标记-整理
3. 对象死亡判定方法:
    - 引用计数: 简单, 但是无法解决对象之间循环引用问题
    - 可达性分析: 通过一系列的`GC Roots`对象作为起始点, 向下搜索, 形成引用链, 当一个对象没有任意一个引用链与之相连则说明此对象不可达, 可作为`GC Root`的对象有:
        - 虚拟机栈中的对象
        - 方法区中类静态属性引用的对象
        - 方法区中常量引用的对象
        - 本地方法栈中native方法引用的对象
4. 垃圾收集器:
    - Serial 收集器: 单线程, 进行收集时停顿所有线程(Stop the World), Client模式下新生代默认的收集器, 简单高效
    - ParNew 收集器: Serial收集器的多线程版本, Server模式下新生代默认的收集器, 唯一可以与CMS收集器搭配使用
    - Parallel Scavenge:  采用复制算法的新生代收集器, 此收集器关注的是达到一个可控制的吞吐量
    - Serial Old: Serial收集器的老年代版本, 单线程, 基于标记整理算法
    - Parallel Old: Parallel 收集器的老年代版本, 多线程, 采取标记整理算法, 在注重吞吐量以及CPU效率的场合使用
    - CMS(Concurrent Mark Sweep) 收集器: 
        - 以最短的停顿时间为目标
        - 采用标记清除算法
        - 标记过程: 初始标记(Stop the world) -> 并发标记 ->重新标记(Stop the world) -> 并发清除
        - 缺点: 对CPU资源非常敏感, 会导致系统吞吐量[(执行用户代码的时间)/(执行用户代码的时间+垃圾收集时间)]降低; 无法处理浮动垃圾; 标记清除算法产生大量的内存碎片
    - G1收集器: 当代收集器发展最前沿的成果之一, 面向的是服务端应用
        - 优点: 并行与并发(充分利用多CPU, 多核环境的硬件优势), 分代收集, 空间整合, 可预测的停顿
        - 运行步骤: 初始标记 -> 并发标记 -> 最终标记 -> 筛选回收
### Others
3. 微服务
4. jvm
5. 事务/aop/ioc/测试
6. JIT
7. transient 不需要序列化
8. 嵌套`synchronized`死锁
9. volatile