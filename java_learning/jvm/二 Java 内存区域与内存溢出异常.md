# Java 内存区域与内存溢出异常
--------------
--------------
## 运行时数据区域 (Program Counter Register)
--------------
### 程序计数器
1. 可以看做是行号指示器， 虚拟机通过计数器来获取下一条执行的指令
2. 线程私有
3. 当前线程执行的是Java方法， 此计数器指示的是正在执行的指令地址。若当前线程执行的事native方法，此计数器值为空(undefined)
-------------
### Java虚拟机栈 (Java Virtral Machine Stacks)
1. Java 方法执行的内存模型
2. 线程私有， 与线程同生命周期
3. 每个方法在执行时会创建`栈帧`用于存储局部变量、操作数栈、动态链接等信息。方法从调用直到结束对应栈帧在虚拟机栈中的入栈和出栈
4. 通常说的堆栈中的`栈`就是指的此虚拟机栈或者说是虚拟机栈的变量表部分
5. Java虚拟机规范在此区域规定了两种异常状况
    * StackOverflowError : 线程请求的栈深度大于虚拟机所允许的深度
    * OutOfMemoryError : 虚拟机栈动态扩展无法申请到足够的内存

-----------
### 本地方法栈 (Native Method Stack)
1. native 方法执行的内存模型 
2. 许多虚拟机合并了虚拟机栈和本地方法栈（Sun HotSpot）
---------
### Java 堆 (Java Heap)
1. 存放对象实例
2. 几乎所有的对象都在堆里分配内存
3. JIT编译器的发展，逃逸分析技术的成熟，栈上分配、标量替换优化技术 使得对象可以不在堆上分配内存
4. Java堆是垃圾收集器管理的主要区域，因此成为`GC`堆(Garbage Collected Heap)
5. 分为新生代和老年代 更细的划分： Eden Space, From Survivor, To Survivor
6. 无可用的内存会抛出 OutOfMemoryError
---------
### 方法区 (Method Area)
1. 线程共享区域
2. 存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。
3. 是Java堆的逻辑部分
4. 无可用内存抛出 OutOfMemoryError
----------
### 运行时常量池 (Runtime Constant Pool)
1. 方法区的一部分
2. Class 文件有一项信息是常量池，用于存放编译期生成的法中字面量和符号引用，这部分内容在类加载进入方法区的运行时常量池中存放
3. 具备动态性，运行期间可以将新的常量放入池中(`String.intern()`)
4. 无可用的内存会抛出 OutOfMemoryError
----------
### 直接内存 (Direct Memory)
1. 不是虚拟机运行时数据区的一部分
2. 使用native函数库直接分配堆外内存，然后通过对象引用进行操作
------------
----------
## HotSpot虚拟机对象
----------
## 对象的创建
----------
1. 检查指令参数是否能够定位到常量池中某个类的符号引用， 然后检查此符号引用代表的类是否已经被加载、解析和初始化过：
    - 检查没通过， 则首先执行类的加载过程
    - 检查通过， 执行下面步骤
2. 为新对象分配内存。对象所需的内存大小在类加载过后便可以完全确定。
    - 指针碰撞(Bump the Pointer): 假设Java堆中的内存是完全规整的, 已分配和未分配内存中间有分界点指针指示器, 分配内存只需移动指针指示器
    - 空闲列表(Free List): Java堆中的内存不是完全规整的, 虚拟机必须维护一个内存列表, 记录可用的内存地址, 分配时在列表中查找一块足够的空间分配给对象, 更新内存列表
3. 对象创建过程线程安全问题
    - 对分配内存空间的动作进行同步处理
    - 把内存分配的动作按照线程划分在不同的空间中进行(本地线程分配缓冲:TLAB, `-XX:+/-UseTLAB`)
4. 初始化对象内存空间为零值(不包括对象头)
5. 在对象头中设置对象是那个类的实例/如何才能找到类的元数据信息/对象的哈希码/对象的GC分代年龄等信息, 
6. 执行 `<init>` 方法, 按照程序员的意愿初始化