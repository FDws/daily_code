# Java 内存区域与内存溢出异常
--------------
--------------
## 运行时数据区域 (Program Counter Register)
--------------
### 程序计数器
1. 可以看做是行号指示器， 虚拟机通过计数器来获取下一条执行的指令
2. 线程私有
3. 当前线程执行的是Java方法， 此计数器指示的是正在执行的指令地址。若当前线程执行的事native方法，此计数器值为空(undefined)
-------------
### Java虚拟机栈 (Java Virtral Machine Stacks)
1. Java 方法执行的内存模型
2. 线程私有， 与线程同生命周期
3. 每个方法在执行时会创建`栈帧`用于存储局部变量、操作数栈、动态链接等信息。方法从调用直到结束对应栈帧在虚拟机栈中的入栈和出栈
4. 通常说的堆栈中的`栈`就是指的此虚拟机栈或者说是虚拟机栈的变量表部分
5. Java虚拟机规范在此区域规定了两种异常状况
    * StackOverflowError : 线程请求的栈深度大于虚拟机所允许的深度
    * OutOfMemoryError : 虚拟机栈动态扩展无法申请到足够的内存

-----------
### 本地方法栈 (Native Method Stack)
1. native 方法执行的内存模型 
2. 许多虚拟机合并了虚拟机栈和本地方法栈（Sun HotSpot）
---------
### Java 堆 (Java Heap)
1. 存放对象实例
2. 几乎所有的对象都在堆里分配内存
3. JIT编译器的发展，逃逸分析技术的成熟，栈上分配、标量替换优化技术 使得对象可以不在堆上分配内存
4. Java堆是垃圾收集器管理的主要区域，因此成为`GC`堆(Garbage Collected Heap)
5. 分为新生代和老年代 更细的划分： Eden Space, From Survivor, To Survivor
6. 无可用的内存会抛出 OutOfMemoryError
---------
### 方法区 (Method Area)
1. 线程共享区域
2. 存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。
3. 是Java堆的逻辑部分
4. 无可用内存抛出 OutOfMemoryError
----------
### 运行时常量池 (Runtime Constant Pool)
1. 方法区的一部分
2. Class 文件有一项信息是常量池，用于存放编译期生成的法中字面量和符号引用，这部分内容在类加载进入方法区的运行时常量池中存放
3. 具备动态性，运行期间可以将新的常量放入池中(`String.intern()`)
4. 无可用的内存会抛出 OutOfMemoryError
----------
### 直接内存 (Direct Memory)
1. 不是虚拟机运行时数据区的一部分
2. 使用native函数库直接分配堆外内存，然后通过对象引用进行操作
------------
----------
## HotSpot虚拟机对象
----------
### 对象的创建

1. 检查指令参数是否能够定位到常量池中某个类的符号引用， 然后检查此符号引用代表的类是否已经被加载、解析和初始化过：
    - 检查没通过， 则首先执行类的加载过程
    - 检查通过， 执行下面步骤
2. 为新对象分配内存。对象所需的内存大小在类加载过后便可以完全确定。
    - 指针碰撞(Bump the Pointer): 假设Java堆中的内存是完全规整的, 已分配和未分配内存中间有分界点指针指示器, 分配内存只需移动指针指示器
    - 空闲列表(Free List): Java堆中的内存不是完全规整的, 虚拟机必须维护一个内存列表, 记录可用的内存地址, 分配时在列表中查找一块足够的空间分配给对象, 更新内存列表
3. 对象创建过程线程安全问题
    - 对分配内存空间的动作进行同步处理
    - 把内存分配的动作按照线程划分在不同的空间中进行(本地线程分配缓冲:TLAB, `-XX:+/-UseTLAB`)
4. 初始化对象内存空间为零值(不包括对象头)
5. 在对象头中设置对象是那个类的实例/如何才能找到类的元数据信息/对象的哈希码/对象的GC分代年龄等信息, 
6. 执行 `<init>` 方法, 按照程序员的意愿初始化
-------
### 对象内存布局(HotSpot为例)
1. 对象头
    - 一部分存储对象自身运行时的数据,如哈希码/GC分代年龄
    - 另一部分类型指针, 指向它的类元数据
2. 实例数据
    - 存储所定义的各种类型的字段内容
3. 对齐填充
    - 占位符作用,使得对象的起始地址为 **8** 的整数倍. 对象头是8的倍数,所以对齐填充是填充的实例数据部分
---------
### 对象的访问定位
1. 程序利用栈上的reference数据来才做堆上的对象
2. 两种主流的访问方法:
    1. 使用句柄:
        - 句柄包含了对象实例数据和类型数据各自的指针
        - 优点: 在对象被移动时只会改变句柄中实例数据指针, reference本身不需要修改
    2. 直接指针:
        - reference直接指向的实例数据地址,需要考虑对象类型数据的存放方法
        - 优点: 快, 节省了一次寻址的过程.
        - HotSpot所采用的方法
----
### OutOfMemoryError
1. 内存泄漏: 虚拟机没有把无用的对象回收, 导致内存被占满
2. 内存溢出: 对象太多以至于无法分配更多内存
3. Java堆溢出
    - 示例代码:
    ```Java
    // -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
    public class HeapOOM {
	    static class OOMObject{	
	    }
	    public static void main(String[] args) {
	    	List<OOMObject> ls = new LinkedList<>();
	    	while (true) {
	    		ls.add(new OOMObject());
		    }
	    }
    }
    /** 报错信息
        java.lang.OutOfMemoryError: GC overhead limit exceeded
        Dumping heap to java_pid640.hprof ...
        Heap dump file created [36625546 bytes in 0.193 secs]
    */
    ```
    - 处理步骤:
        1. 通过内存映像分析工具对dump出的堆转储快照分析, 分析是出现了内存溢出还是内存泄漏
        2. 若是内存泄漏, 进一步分析那些对象通过什么路径关联到了GC根节点(GC Roots), 进一步就可以定位泄露位置代码
        3. 若是内存溢出, 则需要查看虚拟机参数(`-Xms -Xmx`)与物理内存的大小比较, 是否可以多分配内存给虚拟机.同时从代码上查看是否有对象生命周期过长/持有状态过长的问题.
4. 虚拟机栈和本地方法栈溢出
    - HotSpot 虚拟机不区分虚拟机栈和本地方法栈, 所以`-Xoss`参数对HotSpot无效
    - 在单个线程情况下,无论是由于栈帧太大或者虚拟机栈容量太小, 无法分配内存时都抛出的`StackOverflowError`异常
    - 在不能减少线程数的情况下, 可以通过减少最大堆和减少栈容量来换取更多线程
5. 运行时常量池和方法区溢出
    - JDK1.7 中`String.intern()`方法只会记录首次出现实例的引用, 而 JDK1.6 会把实例复制到永久代返回永久代中实例的引用
6. 本机直接内存溢出
    - 直接内存容量可以通过`-XX:MaxDirectMemorySize`指定
    - 未指定时默认与`-Xmx`一样
    - 直接内存溢出堆溢出dump文件中不会有明显异常.若发现dump出的文件很小, 而程序中直接或间接使用了NIO, 则有可能出现直接内存溢出.