# Java 内存区域与内存溢出异常
## 运行时数据区域 (Program Counter Register)
--------------
### 程序计数器
1. 可以看做是行号指示器， 虚拟机通过计数器来获取下一条执行的指令
2. 线程私有
3. 当前线程执行的是Java方法， 此计数器指示的是正在执行的指令地址。若当前线程执行的事native方法，此计数器值为空(undefined)
-------------
### Java虚拟机栈 (Java Virtral Machine Stacks)
1. Java 方法执行的内存模型
2. 线程私有， 与线程同生命周期
3. 每个方法在执行时会创建`栈帧`用于存储局部变量、操作数栈、动态链接等信息。方法从调用直到结束对应栈帧在虚拟机栈中的入栈和出栈
4. 通常说的堆栈中的`栈`就是指的此虚拟机栈或者说是虚拟机栈的变量表部分
5. Java虚拟机规范在此区域规定了两种异常状况
    * StackOverflowError : 线程请求的栈深度大于虚拟机所允许的深度
    * OutOfMemoryError : 虚拟机栈动态扩展无法申请到足够的内存

-----------
### 本地方法栈 (Native Method Stack)
1. native 方法执行的内存模型 
2. 许多虚拟机合并了虚拟机栈和本地方法栈（Sun HotSpot）
---------
### Java 堆 (Java Heap)
1. 存放对象实例
2. 几乎所有的对象都在堆里分配内存
3. JIT编译器的发展，逃逸分析技术的成熟，栈上分配、标量替换优化技术 使得对象可以不在堆上分配内存
4. Java堆是垃圾收集器管理的主要区域，因此成为`GC`堆(Garbage Collected Heap)
5. 分为新生代和老年代 更细的划分： Eden Space, From Survivor, To Survivor
6. 无可用的内存会抛出 OutOfMemoryError
---------
### 方法区 (Method Area)
1. 线程共享区域
2. 存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。
3. 是Java堆的逻辑部分
4. 无可用内存抛出 OutOfMemoryError
----------
### 运行时常量池 (Runtime Constant Pool)
1. 方法区的一部分
2. Class 文件有一项信息是常量池，用于存放编译期生成的法中字面量和符号引用，这部分内容在类加载进入方法区的运行时常量池中存放
3. 具备动态性，运行期间可以将新的常量放入池中(`String.intern()`)
4. 无可用的内存会抛出 OutOfMemoryError
----------
### 直接内存 (Direct Memory)
1. 不是虚拟机运行时数据区的一部分
2. 使用native函数库直接分配堆外内存，然后通过对象引用进行操作