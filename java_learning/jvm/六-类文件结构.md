# 第六章 类文件结构
### 无关性的基石
1. 不同的平台开发不同的虚拟机, 虚拟机屏蔽底层细节
2. 字节码 - 程序无关性的基石
3. Java虚拟机只识别`.class`文件
4. `.class`文件包括了Java虚拟机指令集和符号表以及其他的辅助信息
5. 任何语言只要按照规定生成`.class`文件就可以在Java虚拟机上运行
---------
### Class类文件结构
1. class文件是一组以8位字节为单位的二进制流
2. 当需要大于8位字节的空间时, 按照高位在前的规定划分为多个8位字节存储
3. class文件采用伪结构来存储数据, 伪结构中只有两种数据类型
    - 无符号数: 基本的数据类型, 可以描述数字/索引引用/数量值或者是按照UTF-8编码构成的字符串值
        * u1/u2/u4/u8 表示 1/2/4/8 个字节的无符号数
    - 表: 由多个无符号数或者其他表作为数据项构成的复合数据类型. 整个class文件本质上就是一张表
4. 当需要描述同一类型数量不定的多个数据时, 经常使用一个前置的容量计数器加若干个连续的数据项的形式
-------
##### 魔数与class文件版本
1. 每个class文件的前四个字节称为**魔数**, 确定此文件能否可以被虚拟机接受
2. 5-8字节存储的是版本号
    - 5/6字节存储的次版本号
    - 7/8字节存储主版本号
    - 高版本的虚拟机可以执行低版本的class文件(向下兼容)
    - 低版本的虚拟机不可以执行高版本的class文件
------------
##### 常量池
1. 第九个字节为常量池入口
2. class文件的*资源仓库*, 是class文件中与其他项目关联最多的数据类型
3. 是**表**类型数据项
4. u2类型的数据表示常量池容量计算值
5. 容量计数从 **1** 开始, 0 表示不引用任何常量池内容
6. 主要存储两类常量:
    - 字面量
        * 类似于Java语言中的常量 例如 文本字符串/声明为final的常量值
    - 符号引用
        * 类和接口的全限定名称
        * 字段的名称和描述符
        * 方法的名称和描述符
7. class文件不存放方法/字段的最终内存布局信息, 在虚拟机加载时动态连接
8. 常量池中每一个常量都是一个表
    - 表的第一位是u1类型的标志位, 代表常量类型
         | 类型 | 标志 | 描述
        | :-- | :--: | :-- |
        |CONSTANT_Utf8_info|1|UTF-8编码的字符串|
        |CONSTANT_Integer_info|3|整形字面量|
        |CONSTANT_Float_info|4|浮点型字面量|
        |CONSTANT_Long_info|5|长整型字面量|
        |CONSTANT_Double_info|6|双精度浮点型字面量
        |CONSTANT_Class_info|7|类或者接口的符号引用
        |CONSTANT_String_info|8|字符串类型字面量
        |CONSTANT_Fieldref_info|9|字段符号引用
        |CONSTANT_Methodref_info|10|类中方法的符号引用
        |CONSTANT_InterfaceMethodref_info|11|接口中方法的符号引用
        |CONSTANT_NameAndType_info|12|字段或者方法的部分符号引用
        |CONSTANT_MethodHandle_info|15|方法句柄
        |CONSTANT_MethodType_info|16|方法类型
        |CONSTANT_InvokeDynamic_info|18|动态方法调用点
    - 每种常量类型都有自己的结构
-----------
##### 访问标志
1. 常量池之后的两个字节
2. 识别类或者接口的访问信息: class文件是类or接口, 是否是public, 类是否是final等
3. 共有16个标志位可用, 当前只定义了8个
----
##### 类索引/父类索引与接口索引集合
1. 类索引和父类索引是u2类型的数据 , 接口索引是u2类型的数据的集合
2. 这三项数据确定此类的继承关系
-----
##### 字段表集合
1. 字段表用来描述接口或者类中声明的变量
2. 字段包括类级变量以及实例级变量, 不包括方法内的局部变量
3. 字段表结构:
    * u2类型的字段修饰符(access_flags)
    * u2类型的字段简单名称(name_index) 
    * u2类型的方法或者字段的描述符(descriptor_index)
    * u2类型的属性数量(attributes_count)
    * attribute_info类型的属性表集合
4. 全限定名: 类全名中的`.`换成`/`, 例如类`java.lang.Object`的全限定名为`java/lang/Object`
5. 简单名称: 没有类型和参数修饰的方法或者字段名称
6. 方法和字段的描述符:
    |标识字符|含义|
    |:--:|--|
    |B|byte|
    |C|char|
    |D|double|
    |F|float|
    |I|int|
    |J|long|
    |S|short|
    |Z|boolean|
    |V|void|
    |L|对象类型|
7. 数组类型用前置`[`描述:`String[][] --> "[[java/lang/String;"`, `int[] --> "[I"`
8. 描述方法时, 先参数列表, 后返回值, 参数按照顺序放在`()`中: `int indexOf(char[] a, int x) --> "([CI)I"`
9. 字段表中不会出现继承的字段
------
##### 方法表集合
1. 类比字段表, 标志位少了ACC_VOLATILE 和 ACC_TRANSIENT标志, 多了ACC_NATIVE等可以描述方法的标志位
2. 两个仅返回值不同的方法可以共存在class文件中
------
##### 属性表集合
1. 属性表结构
    |类型|名称|数量
    |:--|:--|:--|
    |u2|attribute_name_index|1|
    |u4|attribute_length|1|
    |u1|info|attribute_length|
2. Code属性
    - 方法中的代码经过编译之后以字节码的形式存储在Code属性内
    - Java程序中, Code用来描述代码, 其他的数据项目描述元数据
    - args_size用于描述参数数量, 当类中有非静态方法时, args_size至少为1, 用于表示`this`
    - 编译器使用异常表来实现Java异常以及finally处理机制
3. Exceptions属性
    - 列出方法中可能抛出的受查异常, 即throws后边的异常
4. LineNumberTable属性
    - 描述Java源代码与字节码行号的偏移量
    - 非必需, 可以用 `-g:none`或者`-g:lines`取消生成此项属性
    - 取消后抛出的异常无法显示行号
5. LocalVariableTable属性
    - 描述栈帧中局部变量表中的变量和Java源码中定义的变量之间的关系
    - 可以取消`-g:none`||`-g:vars`
    - 取消后代码中引用此方法无法获知原参数名, 会被虚拟机生成的例如`arg0`代替, 并且在调试过程中无法从上下文获得参数值
6. SourceFile属性
    - 记录生成此class文件的源码文件名
    - 可以取消 `-g:none`||`-g:source`
    - 取消后抛出异常不会显示出错代码所属文件名
7. ConstantValue属性
    - 通知虚拟机自动为变量赋值, `static`修饰的变量拥有此属性
    - javac 中:
        - `final static`修饰的基本数据类型或者`java.lang.String`变量, 生成ConstantValue属性赋值
        - 其他的在`<cinit>(第一次加载类执行)`方法中初始化
8. InnerClass属性
    - 记录内部类与宿主类的关系
9. Deprecated和Synthetic属性
    - 布尔类型
    - Deprecated表示不推荐使用, 可以用`@Deprecated`注解设置
    - Synthetic表示此方法是编译器产生的
10. StackMapTable属性
    - `@since JDK1.6`
    - 在类加载字节码验证阶段被新类型的检查验证器使用
11. Signature属性
    - `@since JDK1.5`
    - 记录泛型签名信息
12. BootstrapMethods属性
    - `@since JDK1.7`
    - 保存`invokedynamic`指令引用的引导方法限定符